<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[th0x4c 備忘録]]></title>
  <link href="http://th0x4c.github.com/atom.xml" rel="self"/>
  <link href="http://th0x4c.github.com/"/>
  <updated>2013-04-09T21:55:47+09:00</updated>
  <id>http://th0x4c.github.com/</id>
  <author>
    <name><![CDATA[Takashi Hashizume]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[OS] OS コマンドによるボトルネック調査]]></title>
    <link href="http://th0x4c.github.com/blog/2013/04/09/os-bottleneck/"/>
    <updated>2013-04-09T21:47:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2013/04/09/os-bottleneck</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>OS コマンドによるボトルネック調査方法をまとめる。</p>

<ul>
<li>CPU</li>
<li>メモリ</li>
<li>I/O</li>
<li>ネットワーク</li>
</ul>


<h2>環境</h2>

<ul>
<li>OS: CentOS 5.5</li>
<li>Kernel: 2.6.18-194.el5 x86_64</li>
</ul>


<h2>CPU</h2>

<h3>サーバ全体の CPU 使用率</h3>

<p>CPU 使用率を確認する。使用率が 100% に近くなっている(= idle が 0% に近くなっている)とボトルネック。</p>

<h4><code>top</code></h4>

<p><code>top</code> では複数の論理 CPU がある場合もサーバ全体として 1 つに集約されて出力される。</p>

<pre><code>$ top
top - 07:23:36 up 45 days, 17:41,  2 users,  load average: 7.22, 9.43, 8.03
Tasks: 223 total,   1 running, 222 sleeping,   0 stopped,   0 zombie
Cpu(s):  7.1%us,  8.0%sy,  0.0%ni, 70.8%id,  7.1%wa,  2.7%hi,  4.4%si,  0.0%st
Mem:   4044532k total,  3735152k used,   309380k free,   180688k buffers
Swap:  8159224k total,   629880k used,  7529344k free,  1822664k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 1314 oracle    15   0 1800m  83m  63m S  1.3  2.1  16:38.42 oracle
32392 root      15   0  362m  39m  15m S  1.0  1.0  18:24.31 orarootagent.bi
  667 grid      15   0 1244m  41m  16m S  0.7  1.0  11:23.32 oraagent.bin
32450 grid      RT   0  334m 121m  53m S  0.7  3.1  28:04.95 ocssd.bin
  442 grid      15   0  729m  32m  19m S  0.3  0.8   5:04.54 oracle
  676 root      15   0 1681m  27m  13m S  0.3  0.7  22:21.63 orarootagent.bi
 1016 oracle    15   0  826m  36m  16m S  0.3  0.9   7:57.93 oraagent.bin
 1300 oracle    -2   0 1781m  16m  14m S  0.3  0.4   0:28.27 oracle
 1306 oracle    15   0 1787m  24m  17m S  0.3  0.6   0:39.76 oracle
</code></pre>

<p><code>Cpu(s):</code> で始まる行が CPU 使用率</p>

<pre><code>Cpu(s):  7.1%us,  8.0%sy,  0.0%ni, 70.8%id,  7.1%wa,  2.7%hi,  4.4%si,  0.0%st
</code></pre>

<p>(-b オプションによるバッチモードでなく)対話的に起動した場合は <code>1</code> を押すと個々の CPU 毎の
CPU 使用率が出力される。</p>

<pre><code>$ top # 起動後 1 を押下
top - 07:25:32 up 45 days, 17:43,  2 users,  load average: 5.02, 8.37, 7.84
Tasks: 223 total,   1 running, 222 sleeping,   0 stopped,   0 zombie
Cpu0  :  5.6%us, 16.7%sy,  0.0%ni, 33.3%id, 41.7%wa,  0.0%hi,  2.8%si,  0.0%st
Cpu1  :  8.1%us,  5.4%sy,  0.0%ni, 70.3%id, 13.5%wa,  0.0%hi,  2.7%si,  0.0%st
Mem:   4044532k total,  3735368k used,   309164k free,   180704k buffers
Swap:  8159224k total,   629880k used,  7529344k free,  1822916k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
32392 root      15   0  362m  39m  15m S  1.0  1.0  18:24.71 orarootagent.bi
32450 grid      RT   0  334m 121m  53m S  1.0  3.1  28:05.51 ocssd.bin
  676 root      15   0 1681m  27m  13m S  0.7  0.7  22:22.10 orarootagent.bi
 1323 oracle    -2   0 1795m 280m 265m S  0.7  7.1  10:14.08 oracle
32382 grid      15   0  172m  25m  11m S  0.7  0.6   1:30.89 gpnpd.bin
  442 grid      15   0  729m  32m  19m S  0.3  0.8   5:04.61 oracle
  477 grid      15   0  718m  21m  16m S  0.3  0.6   1:58.51 oracle
  667 grid      15   0 1244m  41m  16m S  0.3  1.0  11:23.55 oraagent.bin
 1016 oracle    15   0  826m  36m  16m S  0.3  0.9   7:58.08 oraagent.bin
</code></pre>

<p>本環境は CPU 数が2つのため、以下のようにそれぞれの CPU 使用率が出力されている。</p>

<pre><code>Cpu0  :  5.6%us, 16.7%sy,  0.0%ni, 33.3%id, 41.7%wa,  0.0%hi,  2.8%si,  0.0%st
Cpu1  :  8.1%us,  5.4%sy,  0.0%ni, 70.3%id, 13.5%wa,  0.0%hi,  2.7%si,  0.0%st
</code></pre>

<h4><code>mpstat</code></h4>

<p><code>mpstat</code> でも CPU 使用率が確認できる。デフォルトではすべての CPU が集約されて出力される。</p>

<pre><code>$ mpstat 2 3  # 2秒毎に3回出力
Linux 2.6.18-194.el5 (sv1.local)     04/08/13

07:33:04     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
07:33:06     all    4.41    0.00    4.41   13.24    1.47    0.00    0.00   76.47   1409.09
07:33:08     all    5.06    0.00    3.80    6.33    0.00    2.53    0.00   82.28   1481.40
07:33:10     all   10.61    0.00   10.61   12.12    0.00    3.03    0.00   63.64   1468.75
Average:     all    6.57    0.00    6.10   10.33    0.47    1.88    0.00   74.65   1455.56
</code></pre>

<p>個々の CPU の使用率を確認したい場合は、<code>-P ALL</code> オプションを付与する。</p>

<pre><code>$ mpstat -P ALL 2 3
Linux 2.6.18-194.el5 (sv1.local)     04/08/13

07:35:03     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
07:35:05     all    9.09    0.00    5.19    7.79    0.00    2.60    0.00   75.32   1353.85
07:35:05       0   10.26    0.00    5.13   15.38    2.56    2.56    0.00   64.10   1353.85
07:35:05       1    7.69    0.00    2.56    2.56    0.00    2.56    0.00   84.62      0.00

07:35:05     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
07:35:07     all    5.80    0.00    4.35   10.14    0.00    2.90    0.00   76.81   1412.12
07:35:07       0    3.03    0.00    6.06   12.12    0.00    3.03    0.00   75.76   1412.12
07:35:07       1    5.88    0.00    2.94    8.82    0.00    0.00    0.00   82.35      0.00

07:35:07     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
07:35:09     all   10.00    0.00   15.00   13.33    0.00    1.67    0.00   60.00   1393.55
07:35:09       0    6.45    0.00   19.35   25.81    0.00    3.23    0.00   45.16   1393.55
07:35:09       1   13.33    0.00   13.33    0.00    0.00    0.00    0.00   73.33      0.00

Average:     CPU   %user   %nice    %sys %iowait    %irq   %soft  %steal   %idle    intr/s
Average:     all    8.25    0.00    7.77   10.19    0.00    2.43    0.00   71.36   1384.47
Average:       0    6.80    0.00    9.71   17.48    0.97    2.91    0.00   62.14   1384.47
Average:       1    8.74    0.00    5.83    3.88    0.00    0.97    0.00   80.58      0.00
</code></pre>

<p>各項目の意味は以下の通り。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目    </th>
<th align="left"> 説明                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> CPU     </td>
<td align="left"> CPU番号。ALLの場合は、全CPUの平均値であることを示す。</td>
</tr>
<tr>
<td></td>
<td align="left"> %user   </td>
<td align="left"> ユーザレベル（アプリケーション）のCPU使用率</td>
</tr>
<tr>
<td></td>
<td align="left"> %nice   </td>
<td align="left"> 優先度(ナイス値)によるユーザーレベルのCPU使用率</td>
</tr>
<tr>
<td></td>
<td align="left"> %sys    </td>
<td align="left"> システムレベル(kernel)のCPU使用率</td>
</tr>
<tr>
<td></td>
<td align="left"> %iowait </td>
<td align="left"> ディスクi/o競合によるCPU待機時間割合</td>
</tr>
<tr>
<td></td>
<td align="left"> %irq    </td>
<td align="left"> CPUの割り込み実行時間割合</td>
</tr>
<tr>
<td></td>
<td align="left"> %soft   </td>
<td align="left"> CPUのソフトウェア割り込み実行時間割合</td>
</tr>
<tr>
<td></td>
<td align="left"> %idle   </td>
<td align="left"> CPUのアイドル時間割合(ディスクi/o待機時間はのぞく)</td>
</tr>
<tr>
<td></td>
<td align="left"> intr/s  </td>
<td align="left"> 1秒あたりの平均割り込み数</td>
</tr>
</tbody>
</table>


<h4><code>vmstat</code></h4>

<p><code>vmstat</code> からも CPU 使用率が確認できる。</p>

<pre><code>$ vmstat 2 3
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0 629504 306172 181788 1825200    0    1   105   236   14   12  4  5 85  6  0
10  1 629504 306048 181788 1825200    0    0    35   732  300 1425  7  5 77 11  0
 4  0 629504 306040 181788 1825204    0    0    27     2  236 1552  9 11 75  5  0
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 説明                                                                                  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> r    </td>
<td align="left"> CPUを割り当て中もしくは割り当て可能なプロセスの数。CPUの個数以下であることが望ましい。</td>
</tr>
<tr>
<td></td>
<td align="left"> b    </td>
<td align="left"> 割り込みを禁止しているプロセスの数。I/O待ちなどで割り込み不可能なときに発生。ゼロであることが望ましい。</td>
</tr>
<tr>
<td></td>
<td align="left"> us   </td>
<td align="left"> ユーザー時間の CPU 使用率(nice 時間を含む) </td>
</tr>
<tr>
<td></td>
<td align="left"> sy   </td>
<td align="left"> システム時間の CPU 使用率</td>
</tr>
<tr>
<td></td>
<td align="left"> id   </td>
<td align="left"> アイドル時間の割合</td>
</tr>
<tr>
<td></td>
<td align="left"> wa   </td>
<td align="left"> IO 待ち時間の割合</td>
</tr>
</tbody>
</table>


<p>CPU の割り当て状況を示す r, b の値も重要。r が CPU の個数と同じ場合は、システムの CPU がフルで使われており、
r が CPU 数より多い場合は、CPU の割り当てを待っていて、ボトルネックとなっている状況。
また、b が 0 より大きい場合は、I/O 等 CPU 以外のボトルネックが発生している可能性がある。</p>

<h3>プロセス単位の CPU 使用率</h3>

<p>プロセス単位の CPU 使用率を確認し、CPU 使用率が 100% に近くなっているプロセスが
無いか確認する。</p>

<h4><code>top</code></h4>

<p><code>top</code> によりプロセス単位の CPU 使用率が確認できる。</p>

<p>出力結果の下部にプロセス毎の情報があり、<code>%CPU</code> で CPU 使用率が確認できる。</p>

<pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 1314 oracle    15   0 1800m  83m  63m S  1.3  2.1  16:38.42 oracle
32392 root      15   0  362m  39m  15m S  1.0  1.0  18:24.31 orarootagent.bi
  667 grid      15   0 1244m  41m  16m S  0.7  1.0  11:23.32 oraagent.bin
32450 grid      RT   0  334m 121m  53m S  0.7  3.1  28:04.95 ocssd.bin
  442 grid      15   0  729m  32m  19m S  0.3  0.8   5:04.54 oracle
  676 root      15   0 1681m  27m  13m S  0.3  0.7  22:21.63 orarootagent.bi
 1016 oracle    15   0  826m  36m  16m S  0.3  0.9   7:57.93 oraagent.bin
 1300 oracle    -2   0 1781m  16m  14m S  0.3  0.4   0:28.27 oracle
 1306 oracle    15   0 1787m  24m  17m S  0.3  0.6   0:39.76 oracle
</code></pre>

<p><code>top</code> を対話的に起動すると画面サイズ分しかプロセスが出力されず、すべてのプロセス
が確認できるわけではない。その場合は -b オプションでバッチモードで起動する。
例えば、バッチモードで 2 秒毎に 3 回出力する場合は、<code>top -b -d 2 -n 3</code> とする。</p>

<h4><code>ps aux</code></h4>

<p><code>ps aux</code> の %CPU の項目でプロセス単位の CPU 使用率が確認できる。こちらはすべてのプロセスが
確認できる。</p>

<pre><code>$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  10348   680 ?        Ss   Feb21   0:15 init [5]
root         2  0.0  0.0      0     0 ?        S&lt;   Feb21   5:34 [migration/0]
root         3  0.0  0.0      0     0 ?        SN   Feb21   0:10 [ksoftirqd/0]
root         4  0.0  0.0      0     0 ?        S&lt;   Feb21   3:58 [migration/1]
root         5  0.0  0.0      0     0 ?        SN   Feb21   0:18 [ksoftirqd/1]
root         6  0.0  0.0      0     0 ?        S&lt;   Feb21  33:22 [events/0]
root         7  0.0  0.0      0     0 ?        S&lt;   Feb21   0:06 [events/1]
...
</code></pre>

<h3>プロセス単位で CPU を使用している原因の特定</h3>

<p>CPU を消費しているプロセスを特定したら、プロファイラ(OProfile, Valgrind(Callgrind)など)や
動的トレーサ(strace, ltrace など)で、どの関数で CPU を消費しているか特定していく。
簡易的には <code>pstack</code> を定期的に採取して、どの関数を通っている割合が多そうか確認する。</p>

<h2>メモリ</h2>

<h3>物理メモリ、スワップの確認</h3>

<p>物理メモリのサイズを確認するには次を実行。</p>

<pre><code>$ grep MemTotal /proc/meminfo
MemTotal:      4044532 kB
</code></pre>

<p>スワップのサイズを確認するには次を実行。</p>

<pre><code>$ grep SwapTotal /proc/meminfo
SwapTotal:     8159224 kB
</code></pre>

<h3>サーバ全体の メモリ 使用量</h3>

<p>メモリ使用量を確認して、物理メモリ以上使用されてスワップが多発していないか確認する。</p>

<h4><code>vmstat</code>, <code>free</code>, <code>cat /proc/meminfo</code></h4>

<p>同じタイミングで取得した <code>vmstat</code>, <code>free</code>, <code>cat /proc/meminfo</code> の出力結果は以下</p>

<p><code>vmstat</code> の出力。</p>

<pre><code>$ vmstat 2 3
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0 629504 306172 181788 1825200    0    1   105   236   14   12  4  5 85  6  0
10  1 629504 306048 181788 1825200    0    0    35   732  300 1425  7  5 77 11  0
 4  0 629504 306040 181788 1825204    0    0    27     2  236 1552  9 11 75  5  0
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目  </th>
<th align="left"> 説明                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> swapd </td>
<td align="left"> 仮想メモリの量(KB)</td>
</tr>
<tr>
<td></td>
<td align="left"> free  </td>
<td align="left"> 空きメモリの量(KB)</td>
</tr>
<tr>
<td></td>
<td align="left"> buff  </td>
<td align="left"> バッファに用いられているメモリの量(KB)</td>
</tr>
<tr>
<td></td>
<td align="left"> cache </td>
<td align="left"> キャッシュに用いられているメモリの量(KB)</td>
</tr>
</tbody>
</table>


<p><code>free</code> の出力</p>

<pre><code>$ free
             total       used       free     shared    buffers     cached
Mem:       4044532    3738376     306156          0     181788    1825204
-/+ buffers/cache:    1731384    2313148
Swap:      8159224     629504    7529720
</code></pre>

<p><code>cat /proc/meminfo</code> の出力</p>

<pre><code>$ cat /proc/meminfo
MemTotal:      4044532 kB
MemFree:        306148 kB
Buffers:        181788 kB
Cached:        1825204 kB
SwapCached:     358460 kB
Active:        2598312 kB
Inactive:       867084 kB
HighTotal:           0 kB
HighFree:            0 kB
LowTotal:      4044532 kB
LowFree:        306148 kB
SwapTotal:     8159224 kB
SwapFree:      7529720 kB
Dirty:             588 kB
Writeback:           0 kB
AnonPages:     1099912 kB
Mapped:         687964 kB
Slab:           153028 kB
PageTables:      63084 kB
NFS_Unstable:        0 kB
Bounce:              0 kB
CommitLimit:  10181488 kB
Committed_AS:  6503324 kB
VmallocTotal: 34359738367 kB
VmallocUsed:    286400 kB
VmallocChunk: 34359451067 kB
HugePages_Total:     0
HugePages_Free:      0
HugePages_Rsvd:      0
Hugepagesize:     2048 kB
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目        </th>
<th align="left"> 説明                                                            </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> MemTotal    </td>
<td align="left"> システム全体で利用できる物理メモリの総容量。システム起動時に計算される。その後、この値が変化することはない。</td>
</tr>
<tr>
<td></td>
<td align="left"> MemFree     </td>
<td align="left"> システム全体で利用できる物理メモリの空き容量</td>
</tr>
<tr>
<td></td>
<td align="left"> Buffers     </td>
<td align="left"> ファイルなどのメタデータとして使用している物理メモリの総容量</td>
</tr>
<tr>
<td></td>
<td align="left"> Cached      </td>
<td align="left"> ファイルデータのキャッシュなどに使用している物理メモリの総容量。共有メモリは Cached に加算される。SwapCachedは含まない。</td>
</tr>
<tr>
<td></td>
<td align="left"> SwapCached  </td>
<td align="left"> 物理メモリ上にキャッシュされたスワップページの総容量</td>
</tr>
<tr>
<td></td>
<td align="left"> Active      </td>
<td align="left"> 最近アクセスした（とカーネルが思っている）物理メモリの容量</td>
</tr>
<tr>
<td></td>
<td align="left"> Inactive    </td>
<td align="left"> 最近アクセスしていない（とカーネルが思っている）、解放してよい物理メモリの容量</td>
</tr>
<tr>
<td></td>
<td align="left"> Slab        </td>
<td align="left"> スラブアロケータで使用されている物理メモリの総容量</td>
</tr>
<tr>
<td></td>
<td align="left"> VmallocUsed </td>
<td align="left"> vmalloc()で確保された物理メモリ領域とMMCONFIGで確保しているメモリ領域の総容量</td>
</tr>
<tr>
<td></td>
<td align="left"> AnonPages   </td>
<td align="left"> 無名ページ（Anonymous Page）の領域。無名ページとは、ユーザープロセスがmalloc()などで確保したり、プログラム本体用に利用するメモリ領域。</td>
</tr>
</tbody>
</table>


<p>出力を確認すると以下が分かる。</p>

<ul>
<li>「<code>vmstat</code> の free」 = 「<code>free</code> の Mem: の free」 = 「<code>cat /proc/meminfo</code> の MemFree」</li>
<li>「<code>vmstat</code> の buff」 = 「<code>free</code> の Mem: の buffers」 = 「<code>cat /proc/meminfo</code> の Buffers」</li>
<li>「<code>vmstat</code> の cache」 = 「<code>free</code> の Mem: の cached」 = 「<code>cat /proc/meminfo</code> の Cached」</li>
</ul>


<p>Linux では、空いているメモリはファイル I/O を効率化させるためにページキャッシュ
として利用する。
buffers と cached はページキャッシュ(の一部)であり、実際はストレージと同期がとれ
ていれば再利用可能なメモリである。</p>

<p>したがって利用可能な物理メモリ量は実際は、free + buffers + cached (<code>free</code> の free+)となる。</p>

<pre><code>|================= total =================|
|= free =|============= used =============|

+--------+----------+-----------+---------+
|        |          |           |         |
|        |          |           |         |
|        |          |           |         |
+--------+----------+-----------+---------+

         |= cached =|= buffers =|
|============ free+ ============|= used- =|
</code></pre>

<p>厳密には、使用可能な物理メモリは「ストレージと同期されていない」ページキャッシュを除かないといけない。
ストレージと同期されており、すぐに再利用可能なメモリは「<code>cat /proc/meminfo</code> の Inactive 」
(もしくは <code>vmstat -a</code>)にて確認ができる。したがって、実際に再利用可能なメモリは厳密には「<code>cat /proc/meminfo</code> の MemFree + Inactive」
となる。(概算としては、free + buffers + cached でよいと思う。)</p>

<p>ちなみに /proc/meminfo に関して原則として、以下のような計算式が成り立つ。</p>

<ul>
<li>MemTotal = MemFree + Active + Inactive + Slab + VmallocUsed + PageTables</li>
<li>Active + Inactive = AnonPages + Cached + Buffers + SwapCached</li>
<li>利用可能なメモリ = MemFree + Inactive, 解放できないメモリ = Active + Slab + VmallocUsed + PageTables</li>
</ul>


<h4>スワップ状況の確認</h4>

<p>サーバ全体のスワップ状況は、<code>vmstat</code> の swap 欄の si(ディスクからページインされるメモリの量 KB/秒),
so(ディスクにページアウトしているメモリ量 KB/秒)から確認する。
si, so が定常的に 0 より大きい場合は、スワップが発生しているのでメモリ不足に陥っている。</p>

<pre><code>$ vmstat 2    # メモリを使用するプログラムを実行中

procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
20  1 731484  36160 180152 1722248    0    1   105   238    7    9  4  5 84  6  0
16  1 731484  31292 180152 1722248    0    0    69    80  151  788 22 78  0  0  0
13  3 731484  26836 180152 1722248    0    0    19   168  149  807 23 69  8  0  0
 2  0 733040  26528 179984 1720100    0    0    34    55  134  850 22 53 13 13  0
...&lt;中略&gt;
19  2 797140  24992   4276 787872    0 2804    56  2859  254 1024 38 62  0  0  0
19  1 814564  26708   2404 761484    0 5008   131  5191  246  912 37 63  0  0  0
 6  1 816372  25500   2236 755376    0  626   113   882  156  599 35 65  0  0  0
28  4 824480  26208   1516 739372    0 3912   871  3934  265 1038 28 61  0 10  0
16  2 840912  24156   1232 725428    0 3166   963  3216  196  834 30 66  0  5  0
19  4 861804  25324   1268 718716    0 6790   323  7015  222  839 34 66  0  0  0
 7  2 890208  28728   1296 709336    0 8648   878  8650  282 1061 30 66  2  3  0
19  3 919964  34312   1376 707076    0 10578   399 10820  293 1106 29 66  0  5  0
24  6 987308  55048   1384 707584    0 24256   293 24326  425 1415 36 64  0  0  0
 2  9 987292  38232   1444 707816   32    0   207   158  189  738 48 50  0  2  0
 6  2 1009184  33604   1504 709208    0 10228   780 10291  342 1047 30 58  5  7  0
 5  2 1014212  26284   1536 709544    0 2078   259  2086  151  798 37 55  0  8  0
21  1 1030672  27936   1556 710044   16 7522   323  7758  225  944 37 58  2  3  0
10  1 1041180  26028   1604 710244   18 5318   239  5320  207 1013 38 62  0  0  0
24  5 1049788  28312   1632 710332    0 3618    31  3681  117  494 44 56  0  0  0
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 説明                                                                </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> si   </td>
<td align="left"> ディスクからスワップインされているメモリの量 (KB/s)</td>
</tr>
<tr>
<td></td>
<td align="left"> so   </td>
<td align="left"> ディスクにスワップしているメモリの量 (KB/s)</td>
</tr>
</tbody>
</table>


<p>また、スワップ時は <code>kswapd0</code> というカーネルスレッドが動作するので、これが <code>top</code> などで確認して
CPU 使用率の上位に出現しているとスワップが多発している状況と判断できる。</p>

<h3>プロセス単位の メモリ 使用量</h3>

<p>プロセス単位のメモリ使用量を確認して、物理メモリを多く消費しているプロセスが無いか確認する。</p>

<h4><code>top</code></h4>

<p>VIRT, RES, SHR, %MEM から確認する。RES が物理メモリ使用量。</p>

<pre><code>$ top
top - 11:41:10 up 46 days, 21:59,  3 users,  load average: 9.69, 8.95, 7.96
Tasks: 226 total,   9 running, 217 sleeping,   0 stopped,   0 zombie
Cpu(s):  3.8%us,  4.4%sy,  0.1%ni, 84.5%id,  6.1%wa,  0.3%hi,  0.8%si,  0.0%st
Mem:   4044532k total,  2077900k used,  1966632k free,     7208k buffers
Swap:  8159224k total,   938488k used,  7220736k free,   745852k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
  477 grid      15   0  718m  21m  16m S  1.0  0.6   2:35.70 oracle
  667 grid      15   0 1247m  44m  16m S  1.0  1.1  15:30.20 oraagent.bin
 1310 oracle    15   0 1781m  17m  15m S  1.0  0.4   1:34.40 oracle
 1314 oracle    15   0 1800m  84m  64m S  1.0  2.1  21:53.70 oracle
32241 root      15   0  319m  51m  21m S  1.0  1.3   7:56.18 ohasd.bin
32360 grid      15   0  310m  35m  15m S  1.0  0.9   7:53.41 oraagent.bin
32582 root      16   0  240m  21m  10m S  1.0  0.6   8:48.50 octssd.bin
    1 root      15   0 10348  672  568 S  0.0  0.0   0:15.40 init
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 説明                                                                </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> VIRT </td>
<td align="left"> 使用している仮想メモリの総量</td>
</tr>
<tr>
<td></td>
<td align="left"> RES  </td>
<td align="left"> 使用しているスワップされていない物理メモリの総量</td>
</tr>
<tr>
<td></td>
<td align="left"> SHR  </td>
<td align="left"> 利用している共有メモリの総量。他のプロセスと共有される可能性がある。</td>
</tr>
<tr>
<td></td>
<td align="left"> %MEM </td>
<td align="left"> 現在使用している利用可能な物理メモリの占有率</td>
</tr>
</tbody>
</table>


<h4><code>ps aux</code></h4>

<p>%MEM, VSZ, RSS から確認する。RSS が物理メモリ使用量。</p>

<pre><code>$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  10348   672 ?        Ss   Feb21   0:15 init [5]
root         2  0.0  0.0      0     0 ?        S&lt;   Feb21   5:40 [migration/0]
...&lt;中略&gt;
grid       477  0.0  0.5 735924 22424 ?        Ss   Apr04   2:35 asm_gmon_+ASM1
...&lt;中略&gt;
grid       667  0.2  1.1 1277500 45740 ?       Ssl  Apr04  15:30 /u01/app/11.2.0.3/grid/bin/oraagent.bin
...&lt;中略&gt;
oracle    1310  0.0  0.4 1823952 17752 ?       Ss   Apr04   1:34 ora_ping_rac1
oracle    1312  0.0  0.4 1823952 17188 ?       Ss   Apr04   0:04 ora_acms_rac1
oracle    1314  0.3  2.1 1843460 86036 ?       Ss   Apr04  21:53 ora_dia0_rac1
...
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 説明                                                                </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> %MEM </td>
<td align="left"> 現在使用している利用可能な物理メモリの占有率</td>
</tr>
<tr>
<td></td>
<td align="left"> VSZ  </td>
<td align="left"> 使用している仮想メモリの総量(KB)</td>
</tr>
<tr>
<td></td>
<td align="left"> RSS  </td>
<td align="left"> 使用しているスワップされていない物理メモリの総量(KB)</td>
</tr>
</tbody>
</table>


<h2>I/O</h2>

<h3>デバイス毎の I/O 状況</h3>

<p>デバイス毎の I/O 状況を確認する。ビジー率が 100% に近かったり、IOPS, スループット(MB/s) が
カタログ・スペックと比較して限界性能に近かったり、定常的に I/O キューが溜まっていると
ボトルネックとなっている。</p>

<h4><code>iostat -x</code></h4>

<p><code>iostat -x</code> によりデバイス毎の I/O 状況が確認できる。
最初の1回目はシステムがブートしてからその時点までの統計情報であるので注意。</p>

<pre><code>$ iostat -x 2 3
Linux 2.6.18-194.el5 (sv1.local)       04/09/2013

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.63    0.01    1.58    1.91    0.00   94.88

Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.22    17.31  0.43  8.47    19.48   206.31    25.34     0.32   36.46   3.53   3.14
sda1              0.00     0.00  0.00  0.00     0.05     0.00    33.95     0.00    4.87   3.33   0.00
sda2              0.21    17.31  0.42  8.47    19.41   206.31    25.38     0.32   36.53   3.53   3.14
sdb               0.01     1.34  0.10  0.20     4.00    12.34    54.49     0.01   24.80   4.21   0.13
sdb1              0.01     1.34  0.10  0.20     4.00    12.34    54.60     0.01   24.85   4.22   0.13
sdc               0.07    13.21  0.52  4.53    49.09   141.94    37.83     0.16   31.58   8.10   4.09
sdc1              0.07    13.21  0.52  4.53    49.09   141.94    37.83     0.16   31.58   8.10   4.09
sdd               0.05     3.10  0.13  0.09    29.64    25.52   244.66     0.01   35.69   5.43   0.12
sdd1              0.05     3.10  0.13  0.09    29.63    25.52   245.32     0.01   35.79   5.45   0.12
dm-0              0.00     0.00  1.01 43.09    66.84   344.69     9.33     1.30   29.41   1.42   6.28
dm-1              0.00     0.00  0.21  0.45     1.65     3.57     8.00     0.03   40.23   0.35   0.02
dm-2              0.00     0.00  0.28  4.73    33.61    37.87    14.26     0.69  137.64   0.42   0.21

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.43    0.00    0.00    2.86    0.00   95.71

Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sda1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sda2              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdb               0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdb1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdc               0.00     7.14  0.00  4.29     0.00    91.43    21.33     0.49  114.33 107.00  45.86
sdc1              0.00     7.14  0.00  4.29     0.00    91.43    21.33     0.49  114.33 107.00  45.86
sdd               0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdd1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
dm-0              0.00     0.00  0.00 11.43     0.00    91.43     8.00     1.83  159.88  40.12  45.86
dm-1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
dm-2              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           1.19    0.00    0.00    1.19    0.00   97.62

Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sda1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sda2              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdb               0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdb1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdc               0.00     5.95  0.00  2.38     0.00    47.62    20.00     0.03    6.50   8.00   1.90
sdc1              0.00     5.95  0.00  2.38     0.00    47.62    20.00     0.03    6.50   8.00   1.90
sdd               0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
sdd1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
dm-0              0.00     0.00  0.00  9.52     0.00    76.19     8.00     0.07    4.62   2.00   1.90
dm-1              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
dm-2              0.00     0.00  0.00  0.00     0.00     0.00     0.00     0.00    0.00   0.00   0.00
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目     </th>
<th align="left"> 説明                                                                                         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> r/s      </td>
<td align="left"> 読み込みリクエスト数(回/秒)</td>
</tr>
<tr>
<td></td>
<td align="left"> w/s      </td>
<td align="left"> 書き込みリクエスト数(回/秒)</td>
</tr>
<tr>
<td></td>
<td align="left"> rsec/s   </td>
<td align="left"> 読み込みセクタ数(個/秒)。1 セクタ = 512bytes なので、512 を掛ければ読み込み byte 量が分かる。</td>
</tr>
<tr>
<td></td>
<td align="left"> wsec/s   </td>
<td align="left"> 書き込みセクタ数(個/秒)。1 セクタ = 512bytes なので、512 を掛ければ書き込み byte 量が分かる。</td>
</tr>
<tr>
<td></td>
<td align="left"> avgqu-sz </td>
<td align="left"> IOリクエストのキュー（待ち行列）の平均サイズ</td>
</tr>
<tr>
<td></td>
<td align="left"> await    </td>
<td align="left"> IOリクエストの平均待ち時間（ミリ秒）。キューにいる時間＋処理時間。</td>
</tr>
<tr>
<td></td>
<td align="left"> svctm    </td>
<td align="left"> IOリクエストの平均処理時間（ミリ秒）</td>
</tr>
<tr>
<td></td>
<td align="left"> %util    </td>
<td align="left"> IOリクエスト実行中の CPU 時間の割合。この値が 100% に近いとビジーであり、ボトルネックとなる。</td>
</tr>
</tbody>
</table>


<p>IOPS は <code>r/s + w/s</code> で算出できる。
スループットについては、<code>rsec/s</code>, <code>wsec/s</code> に 512 を掛ければ byte 単位のスループット(bytes/s)が算出できる。
<code>iostat -x -k</code> というように -k オプションを付与すると書込み量が kB/s で出力されるので見やすくなる。</p>

<p>ちなみに <code>dm-*</code> で表されているデバイスは、デバイス・マッパーと呼ばれるもので Logical Volume に対応している。
<code>lvdisplay</code> で出力される <code>Block device</code> の項目の右の数字や、<code>ls -l /dev/mapper</code> で LV との対応が分かる。</p>

<pre><code>$ sudo /usr/sbin/lvdisplay
  --- Logical volume ---
  LV Name                /dev/VolGroup01/LogVol00
  VG Name                VolGroup01
  LV UUID                hDNPM9-jBMV-7xto-mChi-ubR9-iN3i-styC8L
  LV Write Access        read/write
  LV Status              available
  # open                 1
  LV Size                39.99 GB
  Current LE             10237
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:2

  --- Logical volume ---
  LV Name                /dev/VolGroup00/LogVol00
  VG Name                VolGroup00
  LV UUID                2V6IUo-8Eui-DHq1-Nnzl-g0Pf-Z8HN-FIKz2E
  LV Write Access        read/write
  LV Status              available
  # open                 1
  LV Size                35.94 GB
  Current LE             1150
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:0

  --- Logical volume ---
  LV Name                /dev/VolGroup00/LogVol01
  VG Name                VolGroup00
  LV UUID                sotwax-PxcG-hwzh-dCG7-tkO1-Vy2m-W5qk5M
  LV Write Access        read/write
  LV Status              available
  # open                 1
  LV Size                3.91 GB
  Current LE             125
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:1

$ ls -l /dev/mapper
total 0
crw------- 1 root root  10, 63 Apr  9 16:50 control
brw-rw---- 1 root disk 253,  0 Apr  9 16:50 VolGroup00-LogVol00
brw-rw---- 1 root disk 253,  1 Apr  9 16:50 VolGroup00-LogVol01
brw-rw---- 1 root disk 253,  2 Apr  9 16:55 VolGroup01-LogVol00
</code></pre>

<h2>ネットワーク</h2>

<h3>ネットワークインターフェイス毎の ネットワーク使用状況</h3>

<p>ネットワークインターフェイス毎の ネットワーク使用状況を確認する。
ネットワーク帯域 bps (bit per second), 処理パケット数 pps (packet per second) といったスループットが
カタログ・スペックと比較して限界性能に近いとボトルネックとなっている。
bps は (byte でなく) bit 単位であることに注意。</p>

<p>また、処理するパケット数が多い(chatty な処理)と、CPU のソフトウェア割り込みが多くなるので、CPU 使用率で
ソフトウェア割り込みが多くなっていないかも確認する。(<code>mpstat</code> の <code>%soft</code> の項目から確認できる。)</p>

<h4><code>netstat -e -a -i -n</code></h4>

<p><code>netstat -e -a -i -n</code> によりネットワークインターフェイス毎の ネットワーク使用状況が確認できる。
インターフェイス起動後からの累積値で表されるため、定期的に採取して差分を採る必要がある。</p>

<pre><code>$ netstat -e -a -i -n                                                                                                   vm13 /home/oracle 14:23
Kernel Interface table
eth0      Link encap:Ethernet  HWaddr 00:0C:29:1C:4C:61
          inet addr:192.168.238.138  Bcast:192.168.238.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe1c:4c61/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:8836237 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9148333 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:1491856405 (1.3 GiB)  TX bytes:6627509379 (6.1 GiB)

eth0:1    Link encap:Ethernet  HWaddr 00:0C:29:1C:4C:61
          inet addr:192.168.238.141  Bcast:192.168.238.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

eth0:3    Link encap:Ethernet  HWaddr 00:0C:29:1C:4C:61
          inet addr:192.168.238.140  Bcast:192.168.238.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

eth0:5    Link encap:Ethernet  HWaddr 00:0C:29:1C:4C:61
          inet addr:192.168.238.143  Bcast:192.168.238.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

eth1      Link encap:Ethernet  HWaddr 00:0C:29:1C:4C:6B
          inet addr:192.168.13.14  Bcast:192.168.13.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe1c:4c6b/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:160311137 errors:0 dropped:0 overruns:0 frame:0
          TX packets:139265311 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:118804988857 (110.6 GiB)  TX bytes:84439638737 (78.6 GiB)

eth1:1    Link encap:Ethernet  HWaddr 00:0C:29:1C:4C:6B
          inet addr:169.254.94.158  Bcast:169.254.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:23503874 errors:0 dropped:0 overruns:0 frame:0
          TX packets:23503874 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:20946402718 (19.5 GiB)  TX bytes:20946402718 (19.5 GiB)

sit0      Link encap:IPv6-in-IPv4
          NOARP  MTU:1480  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目       </th>
<th align="left"> 説明           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> MTU        </td>
<td align="left"> MTU 値</td>
</tr>
<tr>
<td></td>
<td align="left"> RX packets </td>
<td align="left"> 受信パケット数</td>
</tr>
<tr>
<td></td>
<td align="left"> TX packets </td>
<td align="left"> 送信パケット数</td>
</tr>
<tr>
<td></td>
<td align="left"> RX bytes   </td>
<td align="left"> 受信バイト数</td>
</tr>
<tr>
<td></td>
<td align="left"> TX bytes   </td>
<td align="left"> 送信バイト数</td>
</tr>
</tbody>
</table>


<h2>まとめ</h2>

<p>まとめると、以下のような点を確認してボトルネックとなっていないか特定する。</p>

<ul>
<li>CPU: CPU 使用率が 100% に近くないか。</li>
<li>メモリ: 物理メモリに空きがあるか(利用可能な物理メモリ量は十分か)、スワップが発生していないか。</li>
<li>I/O: デバイスがビジーでないか、IOPS, スループットがスペック限界に達していないか。</li>
<li>ネットワーク: ネットワークの帯域限界、パケット数の限界に達していないか。</li>
</ul>


<h2>ボトルネック特定のフロー</h2>

<p><a href="https://users.miraclelinux.com/technet/document/linux/training/2_5_4.html">4.メモリ使用率(第5章 パフォーマンス管理～上級:基本管理コースII)</a> のフローが参考になる。</p>

<h3>システム全体の調査</h3>

<pre><code>+---------+
| vmstat  |
+----+----+
     |
     V
+---------+  Yes   +------------------+
| id &lt; 10 +-------&gt;| CPU 使用率の評価 |
+----+----+        +------------------+
     |
     | No
     V
+---------+  No    +------------------+
| so &gt;  0 +-------&gt;| Disk 使用率の評価|
+----+----+        +------------------+
     |
     | Yes
     V
+----------+
|メモリ不足|
+----------+
</code></pre>

<h3>CPU 使用率の調査</h3>

<pre><code>+---------+
| vmstat  |
+----+----+
     |
     V
+---------+  Yes   
| sy &gt; 30 +-------------+
+----+----+             |
     |                  V
     | No          +----------+  No    +------------------+
     |             | in &gt; 200 +-------&gt;| Disk 使用率の評価|
     |             +----+-----+        +------------------+
     |                  |
     |                  | Yes
     |                  V
     |             +------------------+
     |             |ハードウェアの問題|
     V             +------------------+
+----------+  Yes
|  r &gt; 0   +-------------+
+----+-----+             |
     |                   |
     | No                |
     V                   V
+------------+     +------------+
|CPU のアップ|     | CPU の追加 |
|グレード    |     +------------+
+------------+
</code></pre>

<h3>Disk 使用率の調査</h3>

<pre><code>+---------+
|iostat -x|
+----+----+
     |
     V
+---------+  Yes   +------------------+
|%util &gt;80+-------&gt;|デバイスの負荷分散|
+----+----+        +------------------+
     |
     | No
     V
+---------+  Yes   +--------------------------+
|w/s &gt; r/s+-------&gt;|ディスク・キャッシュの使用|
+----+----+        +--------------------------+
     |
     | No
     V
+------------------+
|ネットワークの調査|
+------------------+
</code></pre>

<h2>参考</h2>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/0810/01/news134.html">Linuxトラブルシューティング探偵団　番外編（1）：減り続けるメモリ残量！ 果たしてその原因は!? (1/3) - ＠IT</a></li>
<li><a href="http://www.atmarkit.co.jp/ait/articles/0903/25/news131.html"> Linuxトラブルシューティング探偵団　番外編（3）：SystemTapで真犯人を捕まえろ！ (1/4) - ＠IT</a></li>
<li><a href="https://users.miraclelinux.com/technet/document/linux/training/2_5_2.html#training2_5_2">2.CPU使用率(第5章 パフォーマンス管理～上級:基本管理コースII)</a></li>
<li><a href="https://users.miraclelinux.com/technet/document/linux/training/2_5_4.html">4.メモリ使用率(第5章 パフォーマンス管理～上級:基本管理コースII)</a></li>
<li><a href="http://www.oracle.com/technetwork/jp/ats-tech/tech/useful-class-3-520773-ja.html">3. 性能管理実践編(システムリソース管理)</a></li>
<li><a href="http://www.oracle.com/technetwork/jp/ats-tech/tech/useful-class-6-520778-ja.html">6. システムがパフォーマンスを維持するためのメモリ管理について</a></li>
<li><a href="http://www.oracle.com/technetwork/jp/ats-tech/tech/useful-class-9-520784-ja.html">9. I/Oボトルネックの計測</a></li>
<li><a href="http://www.atmarkit.co.jp/fnetwork/netcom/netstat/netstat.html">netstat - ホストのネットワーク統計や状態を確認する</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[OS] メモリリークの調査方法]]></title>
    <link href="http://th0x4c.github.com/blog/2013/04/06/os-memory-leak/"/>
    <updated>2013-04-06T17:29:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2013/04/06/os-memory-leak</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>メモリリークの調査方法をまとめる。</p>

<h2>環境</h2>

<ul>
<li>OS: CentOS 5.5</li>
<li>Kernel: 2.6.18-194.el5 x86_64</li>
<li>GCC: gcc 4.1.2 20080704</li>
<li>GDB: GNU gdb 7.0.1-23.el5</li>
<li>Valgrind: valgrind-3.5.0</li>
</ul>


<h2>サンプルプログラム</h2>

<p>メモリリークが起きるサンプルとして以下を利用する。
<code>leak_func()</code> が実行される度に 2048 bytes メモリリークする。
合計で 101 回 <code>leak_func()</code> が実行されるので 206848bytes(= 2048 * 101 bytes) リークする。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define STR_BYTES 2048</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">my_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Cannot malloc struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">my_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">leak_func</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">leak_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">my_alloc</span><span class="p">(</span><span class="n">STR_BYTES</span><span class="p">);</span>
</span><span class='line'>  <span class="n">leak_str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">my_alloc</span><span class="p">(</span><span class="n">STR_BYTES</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">snprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">STR_BYTES</span><span class="p">,</span> <span class="s">&quot;freed memory&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">snprintf</span><span class="p">(</span><span class="n">leak_str</span><span class="p">,</span> <span class="n">STR_BYTES</span><span class="p">,</span> <span class="s">&quot;leaked memory&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: 0x%016lx, &quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">leak_str</span><span class="p">,</span> <span class="n">leak_str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">my_free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="n">leak_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* leak_str が free() されていないのでリークする */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">leak_func</span><span class="p">();</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Press enter key:&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">getchar</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="n">leak_func</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Press enter key:&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">getchar</span><span class="p">();</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>実行結果は以下。</p>

<pre><code>$ gcc -o memory_leak_sample memory_leak_sample.c
$ ./memory_leak_sample
freed memory: 0x0000000009a19010, leaked memory: 0x0000000009a19820
Press enter key:
freed memory: 0x0000000009a19010, leaked memory: 0x0000000009a1a030
freed memory: 0x0000000009a19010, leaked memory: 0x0000000009a1a840
freed memory: 0x0000000009a19010, leaked memory: 0x0000000009a1b050
&lt;中略&gt;
freed memory: 0x0000000009a19010, leaked memory: 0x0000000009a4b650
freed memory: 0x0000000009a19010, leaked memory: 0x0000000009a4be60
Press enter key:
</code></pre>

<h2>valgrind による調査</h2>

<p><a href="http://valgrind.org">Valgrind</a> は、メモリリークの検出等を行うツール。
プロファイリング等メモリリーク検出以外の機能もあり、メモリリー検出で使用する場合は <code>--tool=memcheck</code> を指定する。</p>

<p>Valgrind を使用して上記サンプルを動作させた例が以下。なお、Valgrind を通してプログラムを実行するとすごく遅くなるので注意。</p>

<pre><code>$ valgrind --tool=memcheck --leak-check=yes --leak-resolution=high --num-callers=40 --undef-value-errors=no --run-libc-freeres=no -v ./memory_leak_sample
==16207== Memcheck, a memory error detector
==16207== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==16207== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==16207== Command: ./memory_leak_sample
==16207==
--16207-- Valgrind options:
--16207--    --tool=memcheck
--16207--    --leak-check=yes
--16207--    --leak-resolution=high
--16207--    --num-callers=40
--16207--    --undef-value-errors=no
--16207--    --run-libc-freeres=no
--16207--    -v
--16207-- Contents of /proc/version:
--16207--   Linux version 2.6.18-194.el5 (mockbuild@builder10.centos.org) (gcc version 4.1.2 20080704 (Red Hat 4.1.2-48)) #1 SMP Fri Apr 2
 14:58:14 EDT 2010
--16207-- Arch and hwcaps: AMD64, amd64-sse3-cx16
--16207-- Page sizes: currently 4096, max supported 4096
--16207-- Valgrind library directory: /usr/lib64/valgrind
--16207-- Reading syms from /home/hashi/tmp/memory_leak_sample (0x400000)
--16207-- Reading syms from /usr/lib64/valgrind/memcheck-amd64-linux (0x38000000)
--16207--    object doesn't have a dynamic symbol table
--16207-- Reading syms from /lib64/ld-2.5.so (0x3e1c600000)
--16207-- Reading suppressions file: /usr/lib64/valgrind/default.supp
--16207-- REDIR: 0x3e1c614620 (strlen) redirected to 0x3803e767 (vgPlain_amd64_linux_REDIR_FOR_strlen)
--16207-- Reading syms from /usr/lib64/valgrind/vgpreload_core-amd64-linux.so (0x4802000)
--16207-- Reading syms from /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so (0x4a03000)
==16207== WARNING: new redirection conflicts with existing -- ignoring it
--16207--     new: 0x3e1c614620 (strlen              ) R-&gt; 0x04a06dc0 strlen
--16207-- REDIR: 0x3e1c614440 (index) redirected to 0x4a06c30 (index)
--16207-- REDIR: 0x3e1c6145f0 (strcmp) redirected to 0x4a06e90 (strcmp)
--16207-- Reading syms from /lib64/libc-2.5.so (0x3e1ca00000)
--16207-- REDIR: 0x3e1ca79ba0 (rindex) redirected to 0x4a06ae0 (rindex)
--16207-- REDIR: 0x3e1ca74c70 (malloc) redirected to 0x4a05d9a (malloc)
--16207-- REDIR: 0x3e1ca797b0 (strlen) redirected to 0x4a06d80 (strlen)
freed memory: 0x0000000004c24040, leaked memory: 0x0000000004c24880
--16207-- REDIR: 0x3e1ca72720 (free) redirected to 0x4a059aa (free)
Press enter key:
freed memory: 0x0000000004c250c0, leaked memory: 0x0000000004c25900
freed memory: 0x0000000004c26140, leaked memory: 0x0000000004c26980
&lt;中略&gt;
freed memory: 0x0000000004c89140, leaked memory: 0x0000000004c89980
freed memory: 0x0000000004c8a1c0, leaked memory: 0x0000000004c8aa00
freed memory: 0x0000000004c8b240, leaked memory: 0x0000000004c8ba80
Press enter key:
==16207==
==16207== HEAP SUMMARY:
==16207==     in use at exit: 206,848 bytes in 101 blocks
==16207==   total heap usage: 202 allocs, 101 frees, 413,696 bytes allocated
==16207==
==16207== Searching for pointers to 101 not-freed blocks
==16207== Checked 73,400 bytes
==16207==
==16207== 2,048 bytes in 1 blocks are definitely lost in loss record 1 of 2
==16207==    at 0x4A05E1C: malloc (vg_replace_malloc.c:195)
==16207==    by 0x40069C: my_alloc (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x400719: leak_func (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x4007AE: main (in /home/hashi/tmp/memory_leak_sample)
==16207==
==16207== 204,800 bytes in 100 blocks are definitely lost in loss record 2 of 2
==16207==    at 0x4A05E1C: malloc (vg_replace_malloc.c:195)
==16207==    by 0x40069C: my_alloc (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x400719: leak_func (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x4007D5: main (in /home/hashi/tmp/memory_leak_sample)
==16207==
==16207== LEAK SUMMARY:
==16207==    definitely lost: 206,848 bytes in 101 blocks
==16207==    indirectly lost: 0 bytes in 0 blocks
==16207==      possibly lost: 0 bytes in 0 blocks
==16207==    still reachable: 0 bytes in 0 blocks
==16207==         suppressed: 0 bytes in 0 blocks
==16207==
==16207== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
==16207== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
</code></pre>

<p>いろいろ出力があるが、以下の出力からどの Call Stack で確保されたメモリがどれだけリークしているか分かる。</p>

<pre><code>==16207== 2,048 bytes in 1 blocks are definitely lost in loss record 1 of 2
==16207==    at 0x4A05E1C: malloc (vg_replace_malloc.c:195)
==16207==    by 0x40069C: my_alloc (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x400719: leak_func (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x4007AE: main (in /home/hashi/tmp/memory_leak_sample)
==16207==
==16207== 204,800 bytes in 100 blocks are definitely lost in loss record 2 of 2
==16207==    at 0x4A05E1C: malloc (vg_replace_malloc.c:195)
==16207==    by 0x40069C: my_alloc (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x400719: leak_func (in /home/hashi/tmp/memory_leak_sample)
==16207==    by 0x4007D5: main (in /home/hashi/tmp/memory_leak_sample)
</code></pre>

<p>上述のやり方だと、シェルから valgrind と共に直接実行できるプログラムでないと調査できない。
デーモンなど直接実行できないプログラムの場合は、ラップするシェルスクリプトを用意するとよい。</p>

<p>例えば、最終的に <code>some_daemon.bin</code> というバイナリが実行されるデーモンがあるとして、以下の
ようにラップするシェルスクリプトを同一名で用意して、元のデーモンと同じように起動・停止すればよい。</p>

<pre><code>$ cp -p /path/to/some_daemon.bin /path/to/some_daemon.bin.backup
$ mv /path/to/some_daemon.bin /path/to/some_daemon.bin.orig
$ vi some_daemon.bin # 以下の内容で作成
--------
#!/bin/sh

ORG_BIN=/path/to/some_daemon.bin.orig
LOG_LOC_AND_PREFIX=/tmp/valgrind_instance.%p.log
VALG_PATH=/usr/bin/valgrind
VALGRIND_OPTS="--log-file=$LOG_LOC_AND_PREFIX --leak-check=yes --leak-resolution=high --num-callers=40 --undef-value-errors=no --run-libc-freeres=no --error-limit=no -v"
export VALGRIND_OPTS

exec $VALG_PATH --tool=memcheck $ORG_BIN "$*"
--------
$ chown root:root some_daemon.bin # 元のバイナリと同じオーナーにする
$ chmod 755 some_daemon.bin       # 元のバイナリと同じパーミッションにする
</code></pre>

<p>これで上記<code>LOG_LOC_AND_PREFIX</code>に指定したファイルにログが出力される。</p>

<h2>pmap と gdb による調査</h2>

<p>プロセスのメモリマップを表示する <code>pmap</code> を採取してリークしている領域を特定し、その内容を <code>gdb</code> から確認する。</p>

<p>まず、<code>pmap</code> を採取して増加している領域を特定する。合わせメモリダンプを確認するために <code>gcore</code> により core を採取しておく。</p>

<p>プログラムを実行</p>

<pre><code>$ ./memory_leak_sample
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007b8e820
Press enter key:
</code></pre>

<p>この時の pmap の結果は以下</p>

<pre><code>$ ps -ef | grep memory_leak_sample
hashi    16639 29479  0 10:47 pts/10   00:00:00 ./memory_leak_sample
$ pmap -x 16639
16639:   ./memory_leak_sample
Address           Kbytes     RSS   Dirty Mode   Mapping
0000000000400000       4       4       0 r-x--  memory_leak_sample
0000000000600000       4       4       4 rw---  memory_leak_sample
0000000007b8e000     132       8       8 rw---    [ anon ]
0000003e1c600000     112      96       0 r-x--  ld-2.5.so
0000003e1c81b000       4       4       4 r----  ld-2.5.so
0000003e1c81c000       4       4       4 rw---  ld-2.5.so
0000003e1ca00000    1336     260       0 r-x--  libc-2.5.so
0000003e1cb4e000    2044       0       0 -----  libc-2.5.so
0000003e1cd4d000      16      12       8 r----  libc-2.5.so
0000003e1cd51000       4       4       4 rw---  libc-2.5.so
0000003e1cd52000      20      16      16 rw---    [ anon ]
00002b2fac886000      12       8       8 rw---    [ anon ]
00002b2fac89f000       8       8       8 rw---    [ anon ]
00007fff1b3a6000      84      12      12 rw---    [ stack ]
ffffffffff600000    8192       0       0 -----    [ anon ]
----------------  ------  ------  ------
total kB           11976     440      76
</code></pre>

<p>合わせて core を採取しておく(上書きされないようにリネームしておく)</p>

<pre><code>$ gcore 16639
0x0000003e1cac5ff0 in __read_nocancel () from /lib64/libc.so.6
Saved corefile core.16639

$ mv core.16639 core.16639.before
</code></pre>

<p>プログラムを進める</p>

<pre><code>$ ./memory_leak_sample
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007b8e820
Press enter key:  &lt;=== エンターキーを押下
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007b8f030
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007b8f840
&lt;中略&gt;
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007bae410
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007baec20
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007baf430
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007bafc40
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007bb0450
&lt;中略&gt;
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007bc0650
freed memory: 0x0000000007b8e010, leaked memory: 0x0000000007bc0e60
Press enter key:
</code></pre>

<p>この時の pmap と core を採取しておく</p>

<pre><code>$ pmap -x 16639
16639:   ./memory_leak_sample
Address           Kbytes     RSS   Dirty Mode   Mapping
0000000000400000       4       4       0 r-x--  memory_leak_sample
0000000000600000       4       4       4 rw---  memory_leak_sample
0000000007b8e000     264     208     208 rw---    [ anon ]
0000003e1c600000     112      96       0 r-x--  ld-2.5.so
0000003e1c81b000       4       4       4 r----  ld-2.5.so
0000003e1c81c000       4       4       4 rw---  ld-2.5.so
0000003e1ca00000    1336     260       0 r-x--  libc-2.5.so
0000003e1cb4e000    2044       0       0 -----  libc-2.5.so
0000003e1cd4d000      16      12       8 r----  libc-2.5.so
0000003e1cd51000       4       4       4 rw---  libc-2.5.so
0000003e1cd52000      20      16      16 rw---    [ anon ]
00002b2fac886000      12      12      12 rw---    [ anon ]
00002b2fac89f000       8       8       8 rw---    [ anon ]
00007fff1b3a6000      84      12      12 rw---    [ stack ]
ffffffffff600000    8192       0       0 -----    [ anon ]
----------------  ------  ------  ------
total kB           12108     644     280

$ gcore 16639
0x0000003e1cac5ff0 in __read_nocancel () from /lib64/libc.so.6
Saved corefile core.16639

$ mv core.16639 core.16639.after
</code></pre>

<p>1回目と2回目の pmap の結果を比較すると、以下の個所で仮想メモリ量が増加している(リークしている)ことが分かる。</p>

<pre><code>5c5
&lt; 0000000007b8e000     132       8       8 rw---    [ anon ]
---
&gt; 0000000007b8e000     264     208     208 rw---    [ anon ]
</code></pre>

<p>仮想メモリ量が 132Kbytes -> 264Kbytes (+132Kbytes)に増加している。
増加したアドレスのメモリダンプを確認して、どのように利用されているか確認してみる。</p>

<p>具体的にはメモリ増加後の core で 0x0000000007b8e000 + 132Kbytes のアドレス(0x7baf000)から
増加した 132Kbytes 分のメモリダンプを確認する。
ダンプを採るときに <code>x/16896xg 0x7baf000</code> としているのは、アドレス <code>0x7baf000</code> から、
8バイト(ジャイアント・ワード)単位で(<code>g</code>)、16896個分を、16進数で(<code>x</code>)出力するということ。
つまり、<code>16896 * 8 = 135168 = 132Kbytes</code> 分が出力される。</p>

<pre><code>$ gdb
(gdb) set height 0
(gdb) file ./memory_leak_sample
(gdb) core-file core.16639.after
(gdb) set logging file core.16639.after.gdb.log
(gdb) set logging on
(gdb) x/16896xg 0x7baf000
0x7baf000:      0x0000000000000000      0x0000000000000000
0x7baf010:      0x0000000000000000      0x0000000000000000
&lt;中略&gt;
0x7baf410:      0x0000000000000000      0x0000000000000000
0x7baf420:      0x0000000000000000      0x0000000000000811
0x7baf430:      0x6d2064656b61656c      0x00000079726f6d65
0x7baf440:      0x0000000000000000      0x0000000000000000
&lt;中略&gt;
0x7bcffe0:      0x0000000000000000      0x0000000000000000
0x7bcfff0:      0x0000000000000000      0x0000000000000000
(gdb) quit
</code></pre>

<p>このメモリダンプが pmap 上増加した分。内容を確認すると以下の文字列が見える。</p>

<pre><code>$ grep -v "0x0000000000000000" core.16639.after.gdb.log
0x7baf430:      0x6d2064656b61656c      0x00000079726f6d65
0x7bafc40:      0x6d2064656b61656c      0x00000079726f6d65
0x7bb0450:      0x6d2064656b61656c      0x00000079726f6d65
0x7bb0c60:      0x6d2064656b61656c      0x00000079726f6d65
&lt;中略&gt;
0x7bbf630:      0x6d2064656b61656c      0x00000079726f6d65
0x7bbfe40:      0x6d2064656b61656c      0x00000079726f6d65
0x7bc0650:      0x6d2064656b61656c      0x00000079726f6d65
0x7bc0e60:      0x6d2064656b61656c      0x00000079726f6d65
</code></pre>

<p><code>0x6d2064656b61656c 0x00000079726f6d65</code> は ASCII で直すと &#8220;leaked memory&#8221;</p>

<pre><code>$ ruby -e 's="6d2064656b61656c"; s.unpack("a2" * (s.size / 2)) {|c| print c.hex.chr}; puts'
m dekael
$ ruby -e 's="00000079726f6d65"; s.unpack("a2" * (s.size / 2)) {|c| print c.hex.chr}; puts'
yrome
</code></pre>

<p>よってプログラム中で &#8220;leaked memory&#8221; を入れている領域がリークしていると分かる。
こんなに明らかに分かるケースは少なく、実際のプログラムではポインタが見えていたり
して、さらに core を追わないとリーク原因箇所が追えないケースが多いと思うがメモリ
リーク原因究明のとっかかりにはなる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[OS] 仮想メモリ空間のメモリマップを調べる]]></title>
    <link href="http://th0x4c.github.com/blog/2012/10/10/os-virtual-memory-map/"/>
    <updated>2012-10-10T23:20:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/10/10/os-virtual-memory-map</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>仮想メモリ空間のアドレス等のメモリマップを調べる。</p>

<p>なお、ちゃんと調べたわけではないので誤りがあるかもしれない。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>Kernel: 2.6.32-300.10.1.el5uek x86_64</li>
</ul>


<h2>仮想メモリ空間のメモリマップ</h2>

<p>Unix/Linux における仮想メモリ空間のメモリマップは一般には以下のようになっている。</p>

<pre><code>+------------------------------+  0x0000000000000000
:                              :
+------------------------------+
|                              |
|  text                        |  機械命令
|                              |
+------------------------------+
|                              |
|  data                        |  初期化された static 変数
|                              |
+------------------------------+
|                              |
|  BSS                         |  初期化されていない static 変数
|                              |
+------------------------------+
|                              |
|  heap                        |  malloc() で動的に確保される領域(上位アドレスに伸びる)
|                              |
+------------------------------+
|             ||||             |
|             VVVV             |
:                              :
:                              :
|                              |
+------------------------------+
|                              |
|  shared memory               |  共有メモリ領域
|                              |
+------------------------------+
|                              |
:                              :
:                              :
|             ^^^^             |
|             ||||             |
+------------------------------+
|                              |
|  stack                       |  関数呼び出しやローカル変数等で使用されるスタック領域(下位アドレスに伸びる)
|                              |
+------------------------------+
|                              |
|  arguments / environments    |  引数と環境変数
|                              |
+------------------------------+
:                              :
:                              :
+------------------------------+  0xffffffffffffffff = 2^64 (64bit の場合)
</code></pre>

<h2>実例</h2>

<p>以下のプログラムでメモリマップを確認する。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;sys/shm.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define STRSIZE 64</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">hello</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">hello_local_world</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">not_initialized_global_world</span><span class="p">[</span><span class="n">STRSIZE</span><span class="p">];</span>
</span><span class='line'><span class="kt">char</span> <span class="n">initialized_global_world</span><span class="p">[</span><span class="n">STRSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;initialized global world&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">not_initialized_static_world</span><span class="p">[</span><span class="n">STRSIZE</span><span class="p">];</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">char</span> <span class="n">initialized_static_world</span><span class="p">[</span><span class="n">STRSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;initialized static world&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">malloc_world</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">shmid</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">shared_memory_world</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">big_malloc_world</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">medium_malloc_world_1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">medium_malloc_world_2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">not_initialized_global_world</span><span class="p">,</span> <span class="s">&quot;not initialized global world&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">not_initialized_static_world</span><span class="p">,</span> <span class="s">&quot;not initialized static world&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">malloc_world</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">STRSIZE</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">malloc_world</span><span class="p">,</span> <span class="s">&quot;malloc world&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">shmid</span> <span class="o">=</span> <span class="n">shmget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">STRSIZE</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
</span><span class='line'>  <span class="n">shared_memory_world</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">shmat</span><span class="p">(</span><span class="n">shmid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">shared_memory_world</span><span class="p">,</span> <span class="s">&quot;shared memory world&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">big_malloc_world</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">big_malloc_world</span><span class="p">,</span> <span class="s">&quot;big malloc world&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">medium_malloc_world_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">131</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">+</span> <span class="mi">905</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">medium_malloc_world_1</span><span class="p">,</span> <span class="s">&quot;medium malloc world 1&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">medium_malloc_world_2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">131</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">+</span> <span class="mi">904</span><span class="p">);</span>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">medium_malloc_world_2</span><span class="p">,</span> <span class="s">&quot;medium malloc world 2&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">not_initialized_global_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">initialized_global_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">not_initialized_static_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">initialized_static_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">malloc_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">shared_memory_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">big_malloc_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">medium_malloc_world_1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">medium_malloc_world_2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello_local_world</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">getchar</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">malloc_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">shmdt</span><span class="p">(</span><span class="n">shared_memory_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">shmctl</span><span class="p">(</span><span class="n">shmid</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">big_malloc_world</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">medium_malloc_world_1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">free</span><span class="p">(</span><span class="n">medium_malloc_world_2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">hello</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello, %s: 0x%016lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">hello_local_world</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">char</span> <span class="n">local_world</span><span class="p">[</span><span class="n">STRSIZE</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">strcpy</span><span class="p">(</span><span class="n">local_world</span><span class="p">,</span> <span class="s">&quot;local world&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="n">hello</span><span class="p">(</span><span class="n">local_world</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>実行結果は以下。</p>

<pre><code>$ gcc -o hello hello.c
$ ./hello ARGworld
hello, ARGworld: 0x00007ffff7269cb5
hello, not initialized global world: 0x0000000000600ec0
hello, initialized global world: 0x0000000000600de0
hello, not initialized static world: 0x0000000000600e80
hello, initialized static world: 0x0000000000600e20
hello, malloc world: 0x0000000001f61010
hello, shared memory world: 0x00007f2eeea0e000
hello, big malloc world: 0x00007f2eee9b0010
hello, medium malloc world 1: 0x00007f2eee98f010
hello, medium malloc world 2: 0x0000000001f61060
hello, local world: 0x00007ffff7269680
</code></pre>

<p>メモリマップは <code>pmap</code> や <code>cat /proc/&lt;PID&gt;/maps</code> や <code>cat /proc/&lt;PID&gt;/smaps</code> で確認できる。</p>

<pre><code>$ pmap -x 19671
19671:   ./hello ARGworld
Address           Kbytes     RSS   Dirty Mode   Mapping
0000000000400000       4       4       0 r-x--  hello
0000000000600000       4       4       4 rw---  hello
0000000001f61000     132       8       8 rw---    [ anon ]
00000037be000000     112      96       0 r-x--  ld-2.5.so
00000037be21c000       4       4       4 r----  ld-2.5.so
00000037be21d000       4       4       4 rw---  ld-2.5.so
00000037be400000    1340     248       0 r-x--  libc-2.5.so
00000037be54f000    2044       0       0 -----  libc-2.5.so
00000037be74e000      16      12       8 r----  libc-2.5.so
00000037be752000       4       4       4 rw---  libc-2.5.so
00000037be753000      20      16      16 rw---    [ anon ]
00007f2eee98d000     408      20      20 rw---    [ anon ]
00007f2eeea0e000       4       4       4 rw-s-    [ shmid=0x578006 ]
00007f2eeea0f000       8       8       8 rw---    [ anon ]
00007ffff7255000      84       8       8 rw---    [ stack ]
00007ffff730e000       4       4       0 r-x--    [ anon ]
ffffffffff600000       4       0       0 r-x--    [ anon ]
----------------  ------  ------  ------
total kB            4196     444      88

$ cat /proc/19671/maps 
00400000-00401000 r-xp 00000000 fd:00 5101878                            /tmp/hello
00600000-00601000 rw-p 00000000 fd:00 5101878                            /tmp/hello
01f61000-01f82000 rw-p 00000000 00:00 0                                  [heap]
37be000000-37be01c000 r-xp 00000000 fd:00 1871272                        /lib64/ld-2.5.so
37be21c000-37be21d000 r--p 0001c000 fd:00 1871272                        /lib64/ld-2.5.so
37be21d000-37be21e000 rw-p 0001d000 fd:00 1871272                        /lib64/ld-2.5.so
37be400000-37be54f000 r-xp 00000000 fd:00 1871273                        /lib64/libc-2.5.so
37be54f000-37be74e000 ---p 0014f000 fd:00 1871273                        /lib64/libc-2.5.so
37be74e000-37be752000 r--p 0014e000 fd:00 1871273                        /lib64/libc-2.5.so
37be752000-37be753000 rw-p 00152000 fd:00 1871273                        /lib64/libc-2.5.so
37be753000-37be758000 rw-p 00000000 00:00 0 
7f2eee98d000-7f2eee9f3000 rw-p 00000000 00:00 0 
7f2eeea0e000-7f2eeea0f000 rw-s 00000000 00:04 5734406                    /SYSV00000000 (deleted)
7f2eeea0f000-7f2eeea11000 rw-p 00000000 00:00 0 
7ffff7255000-7ffff726a000 rw-p 00000000 00:00 0                          [stack]
7ffff730e000-7ffff730f000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre>

<p><code>size</code> コマンドで text や BSS のサイズを確認できる。</p>

<pre><code>$ size hello
   text    data     bss     dec     hex filename
   2414     704     160    3278     cce hello

$ size --format=SysV -x hello
hello  :
section           size       addr
.interp           0x1c   0x400200
.note.ABI-tag     0x20   0x40021c
.gnu.hash         0x1c   0x400240
.dynsym          0x108   0x400260
.dynstr           0x6d   0x400368
.gnu.version      0x16   0x4003d6
.gnu.version_r    0x20   0x4003f0
.rela.dyn         0x18   0x400410
.rela.plt         0xd8   0x400428
.init             0x18   0x400500
.plt              0xa0   0x400518
.text            0x488   0x4005c0
.fini              0xe   0x400a48
.rodata           0x25   0x400a58
.eh_frame_hdr     0x34   0x400a80
.eh_frame         0xd4   0x400ab8
.ctors            0x10   0x600b90
.dtors            0x10   0x600ba0
.jcr               0x8   0x600bb0
.dynamic         0x190   0x600bb8
.got               0x8   0x600d48
.got.plt          0x60   0x600d50
.data             0xa0   0x600dc0
.bss              0xa0   0x600e60
.comment         0x114        0x0
Total            0xde2
</code></pre>

<p>これらから次のようなメモリマップとなっていると考えられる。</p>

<pre><code>+------------------------------+  0x0000000000000000
:                              :
+------------------------------+  0x0000000000400000
|text                          |  機械命令
|                              |
+------------------------------+  0x0000000000401000
:                              :
+------------------------------+  0x0000000000600000
|                              |  0x0000000000600dc0
|data                          |  初期化された static 変数
|  initialized global var      |  0x0000000000600de0
|  initialized static var      |  0x0000000000600e20
|                              |
+------------------------------+  0x0000000000600e60
|BSS                           |  初期化されていない static 変数
|  not initialized static var  |  0x0000000000600e80
|  not initialized global var  |  0x0000000000600ec0
|                              |
+------------------------------+  0x0000000000601000
:                              :
+------------------------------+  0x0000000001f61000
|heap                          |  malloc() で動的に確保される領域(上位アドレスに伸びる)
|  malloc var                  |  0x0000000001f61010
|  malloc var                  |  0x0000000001f61060
|                              |
+------------------------------+  0x0000000001f82000
|             ||||             |
|             VVVV             |
:                              :
:                              :
|                              |
+------------------------------+  0x00000037be000000
|                              |
|  共有ライブラリ              |
|  (ld-2.5.so, libc-2.5.so)    |
+------------------------------+  0x00000037be753000
| ???                          |
+------------------------------+  0x00000037be758000
|                              |
:                              :
:                              :
|             ^^^^ ??          |
|             |||| ??          |
+------------------------------+  0x00007f2eee98d000
|heap??                        |
|  malloc var                  |  0x00007f2eee98f010
|  big malloc var              |  0x00007f2eee9b0010
|                              |
+------------------------------+  0x00007f2eee9f3000
:                              :
+------------------------------+  0x00007f2eeea0e000
|shared memory                 |  共有メモリ領域
|  shared memory var           |  0x00007f2eeea0e000
|                              |
+------------------------------+  0x00007f2eeea0f000
|???                           |
+------------------------------+  0x00007f2eeea11000
|                              |
:                              :
:                              :
|             ^^^^             |
|             ||||             |
+------------------------------+  0x00007ffff7255000
|stack                         |  関数呼び出しやローカル変数等で使用されるスタック領域(下位アドレスに伸びる)
|  local var                   |  0x00007ffff7269680
|  arguments[1]                |  0x00007ffff7269cb5
|                              |
+------------------------------+  0x00007ffff726a000
:                              :
+------------------------------+  0x00007ffff730e000
|???                           |
+------------------------------+  0x00007ffff730f000
|                              |
:                              :
:                              :
|                              |
+------------------------------+  0xffffffffff600000
|arguments / environments??    |
|                              |
+------------------------------+  0xffffffffff601000
:                              :
:                              :
+------------------------------+  0xffffffffffffffff = 2^64 (64bit の場合)
</code></pre>

<p>heap としては 0x0000000001f61000 〜 0x0000000001f82000 の 132Kbytes が割り当てられているようだが、
約132Kbytes より大きく malloc() で動的にメモリを割り当てるとアドレスが飛んで 0x00007f2eee98d000 付近に
メモリが割り当てられ、しかも下位にメモリが伸びているようだ。</p>

<h2>参考</h2>

<ul>
<li><a href="http://www.coins.tsukuba.ac.jp/~yas/coins/os2-2011/2012-01-24/index.html">メモリ管理、アドレス空間、ページテーブル</a></li>
<li><a href="http://blog.gakitama.com/?e=490">おじさんＯＳ講座（１）：pmapを使ってみよう</a></li>
<li><a href="http://www.valinux.co.jp/contents/tech/techlib/eos/malloc/malloc_001.html">mallocライブラリのメモリ管理構造</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[GDB] 別環境で採取した core ファイルを解析する方法]]></title>
    <link href="http://th0x4c.github.com/blog/2012/10/10/gdb-analyze-a-core-file/"/>
    <updated>2012-10-10T20:28:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/10/10/gdb-analyze-a-core-file</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>別環境で採取した core ファイルを解析する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>GDB: GNU gdb 7.0.1-42.el5</li>
</ul>


<h2>解析に必要なファイル</h2>

<p>別環境で発生した core ファイルを解析するためには以下のファイルが必要。</p>

<ul>
<li>core ファイル</li>
<li>実行ファイル</li>
<li>共有ライブラリ</li>
</ul>


<p>例えば、以下のように <code>abort()</code> でわざと core を吐かせて試してみる。</p>

<pre><code>$ cat prog1.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  printf("hello, world\n");
  abort();
  return 0;
}

$ gcc -o hello hello.c
$ ./hello
hello, world
Aborted (core dumped)
$ ls -ltr | tail -1
-rw------- 1 oracle oinstall 184320 Oct 10 20:59 core.7441
</code></pre>

<p>core.7441 という core ファイルが吐かれた。</p>

<p>実行ファイルは core ファイルに対して <code>file</code> コマンドを実行すれば確認できる。</p>

<pre><code>$ file core.7441
core.7441: ELF 64-bit LSB core file AMD x86-64, version 1 (SYSV), SVR4-style, from 'hello'
</code></pre>

<p><code>hello</code> という実行ファイルによってこの core が吐かれたことが分かる。</p>

<p>共有ライブラリは GDB で core を読み込んで <code>info share</code> で確認できる。</p>

<pre><code>$ gdb ./hello ./core.7441 
GNU gdb (GDB) Red Hat Enterprise Linux (7.0.1-42.el5)
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /tmp/hello...(no debugging symbols found)...done.
[New Thread 7441]
Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
Core was generated by `./hello'.
Program terminated with signal 6, Aborted.
#0  0x00000037be430265 in raise () from /lib64/libc.so.6
(gdb) info share
From                To                  Syms Read   Shared Object Library
0x00000037be41d780  0x00000037be50ad68  Yes (*)     /lib64/libc.so.6
0x00000037be000a70  0x00000037be01682e  Yes (*)     /lib64/ld-linux-x86-64.so.2
(*): Shared library is missing debugging information.
</code></pre>

<p>共有ライブラリとしては以下が読み込まれていることが分かる。</p>

<ul>
<li>/lib64/libc.so.6</li>
<li>/lib64/ld-linux-x86-64.so.2</li>
</ul>


<p>なお、実行中に動的リンクを行うようなプログラムでなければ、共有ライブラリは <code>ldd</code> コマンドでも確認できる。</p>

<pre><code>$ ldd ./hello
        linux-vdso.so.1 =&gt;  (0x00007fffcd1ff000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00000037be400000)
        /lib64/ld-linux-x86-64.so.2 (0x00000037be000000)
</code></pre>

<p>以上より、この例では他の環境でこの core ファイルを解析するためには次のファイルを採取する必要がある。</p>

<ul>
<li>core ファイル => core.7441</li>
<li>実行ファイル => hello</li>
<li>共有ライブラリ => /lib64/libc.so.6, /lib64/ld-linux-x86-64.so.2</li>
</ul>


<h2>別環境での core の解析</h2>

<p>別環境に先ほど採取したファイルを展開する。
今回は以下のように配置した。</p>

<pre><code>/tmp/core.7441
/tmp/bin/hello
/tmp/lib/libc.so.6
/tmp/lib/ld-linux-x86-64.so.2
</code></pre>

<p>GDB でこの core を解析するためには、採取した共有ライブラリを読み込むために以下のように <code>solib-absolute-prefix</code>, <code>solib-search-path</code> を設定する。</p>

<pre><code>$ cd /tmp
$ gdb
(gdb) set solib-absolute-prefix /tmp/lib
(gdb) set solib-search-path /tmp/lib
(gdb) file ./bin/hello
(gdb) core-file ./core.7441 
</code></pre>

<p>実際の実行例は以下。</p>

<pre><code>$ gdb
GNU gdb (GDB) Red Hat Enterprise Linux (7.0.1-42.el5)
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
(gdb) set solib-absolute-prefix /tmp/lib
(gdb) set solib-search-path /tmp/lib
(gdb) file ./bin/hello
Reading symbols from /tmp/bin/hello...(no debugging symbols found)...done.
(gdb) core-file ./core.7441 
[New Thread 7441]
Reading symbols from /tmp/lib/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /tmp/lib/libc.so.6
Reading symbols from /tmp/lib/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
Loaded symbols for /tmp/lib/ld-linux-x86-64.so.2
Core was generated by `./hello'.
Program terminated with signal 6, Aborted.
#0  0x00000037be430265 in raise () from /tmp/lib/libc.so.6
(gdb) bt
#0  0x00000037be430265 in raise () from /tmp/lib/libc.so.6
#1  0x00000037be431d10 in abort () from /tmp/lib/libc.so.6
#2  0x00000000004004f6 in main ()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] SQL 計画管理]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-sql-plan-management/"/>
    <updated>2012-09-16T23:28:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-sql-plan-management</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>SQL 計画管理により、実行計画を固定化する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
-> 15 SQL計画の管理の使用方法<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/optplanmgmt.htm#BABEGJGB">15.2 SQL計画ベースラインの管理</a></li>
</ul>


<h2>SQL 計画管理</h2>

<p>SQL 計画管理により、実行計画を固定化することができる。具体的には次のステップで行う。</p>

<ol>
<li>SQL 計画の自動取得(<code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=TRUE</code>)</li>
<li>実行計画を管理する SQL を 2 回以上実行</li>
<li>取得した SQL 計画の使用(<code>OPTIMIZER_USE_SQL_PLAN_BASELINES=TRUE</code>)</li>
</ol>


<p>実際に実行してみる。</p>

<ul>
<li>SQL 計画の自動取得(<code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=TRUE</code>)</li>
</ul>


<p><code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES</code> 初期化パラメータ(デフォルト <code>FALSE</code>)を <code>TRUE</code> に設定することで SQL 計画の自動取得が有効になる。</p>

<pre><code>SQL&gt; ALTER SESSION SET OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=TRUE;

Session altered.
</code></pre>

<ul>
<li>SQL を 2 回以上実行</li>
</ul>


<p>SQL を 2 回以上実行して、SQL 計画ベースラインに保存する。</p>

<pre><code>SQL&gt; SELECT * FROM scott.emp WHERE empno = 7900;

     EMPNO ENAME                          JOB                                MGR HIREDATE        SAL       COMM     DEPTNO
---------- ------------------------------ --------------------------- ---------- -------- ---------- ---------- ----------
      7900 JAMES                          CLERK                             7698 81-12-03        960                    30

SQL&gt; SELECT * FROM scott.emp WHERE empno = 7900;

     EMPNO ENAME                          JOB                                MGR HIREDATE        SAL       COMM     DEPTNO
---------- ------------------------------ --------------------------- ---------- -------- ---------- ---------- ----------
      7900 JAMES                          CLERK                             7698 81-12-03        960                    30
</code></pre>

<ul>
<li>SQL 計画の自動取得を無効化(<code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=FALSE</code>)</li>
</ul>


<p>SQL 計画の自動取得を無効化する。</p>

<pre><code>SQL&gt; ALTER SESSION SET OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=FALSE;

Session altered.
</code></pre>

<ul>
<li>SQL が SQL 計画ベースラインに保存されたことを確認</li>
</ul>


<p><code>DBA_SQL_PLAN_BASELINES</code> を確認する。</p>

<pre><code>SQL&gt; col sql_text for a60
     col sql_handle for a30
     col plan_name for a30
     set lines 200
SQL&gt; SELECT SQL_TEXT, SQL_HANDLE, PLAN_NAME, ENABLED, ACCEPTED, FIXED
     FROM   DBA_SQL_PLAN_BASELINES;

SQL_TEXT                                                     SQL_HANDLE                     PLAN_NAME                      ENABLED   ACCEPTED  FIXED
------------------------------------------------------------ ------------------------------ ------------------------------ --------- --------- ---------
SELECT * FROM scott.emp WHERE empno = 7900                   SQL_84ec680ef31d6de4           SQL_PLAN_89v381vtjuvg4695cc014 YES       YES       NO
</code></pre>

<p>実行計画を確認する。</p>

<pre><code>SQL&gt; SELECT * FROM TABLE(
       DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(
         sql_handle=&gt;'SQL_84ec680ef31d6de4',
         format=&gt;'basic'));

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
SQL handle: SQL_84ec680ef31d6de4
SQL text: SELECT * FROM scott.emp WHERE empno = 7900
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Plan name: SQL_PLAN_89v381vtjuvg4695cc014         Plan id: 1767686164
Enabled: YES     Fixed: NO      Accepted: YES     Origin: AUTO-CAPTURE
--------------------------------------------------------------------------------


PLAN_TABLE_OUTPUT
----------------------------------------------
Plan hash value: 2949544139

----------------------------------------------
| Id  | Operation                   | Name   |
----------------------------------------------
|   0 | SELECT STATEMENT            |        |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |
|   2 |   INDEX UNIQUE SCAN         | PK_EMP |
----------------------------------------------

20 rows selected.
</code></pre>

<ul>
<li>取得した SQL 計画の使用(<code>OPTIMIZER_USE_SQL_PLAN_BASELINES=TRUE</code>)</li>
</ul>


<p><code>OPTIMIZER_USE_SQL_PLAN_BASELINES</code> 初期化パラメータ(デフォルト <code>TRUE</code>)を <code>TRUE</code> に設定することで取得した SQL 計画を使用する。</p>

<pre><code>SQL&gt; ALTER SESSION SET OPTIMIZER_USE_SQL_PLAN_BASELINES=TRUE;

Session altered.
</code></pre>

<p>あとは普通に SQL を実行するだけで取得した SQL 計画が使用される。</p>

<pre><code>SQL&gt; set autotrace on
SQL&gt; SELECT * FROM scott.emp WHERE empno = 7900;

     EMPNO ENAME                          JOB                                MGR HIREDATE        SAL       COMM     DEPTNO
---------- ------------------------------ --------------------------- ---------- -------- ---------- ---------- ----------
      7900 JAMES                          CLERK                             7698 81-12-03        960                    30


Execution Plan
----------------------------------------------------------
Plan hash value: 2949544139

--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    39 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    39 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("EMPNO"=7900)

Note 
-----
   - SQL plan baseline "SQL_PLAN_89v381vtjuvg4695cc014" used for this statement


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          2  consistent gets
          0  physical reads
          0  redo size
        889  bytes sent via SQL*Net to client
        512  bytes received via SQL*Net from client
          1  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>Note の <code>SQL plan baseline "SQL_PLAN_89v381vtjuvg4695cc014" used for this statement</code> という出力から取得した SQL 計画が使用されていることが分かる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] カーソルを無効にしない統計情報の取得]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-does-not-invalidate-the-dependent-cursors-when-gathering-statistics/"/>
    <updated>2012-09-16T21:34:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-does-not-invalidate-the-dependent-cursors-when-gathering-statistics</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>カーソルを無効化せずに統計情報を取得する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス<br/>
-> 141 DBMS_STATS<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56262/d_stats.htm#i1036461">GATHER_TABLE_STATSプロシージャ</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56262/d_stats.htm#BEIBJJHC">SET_TABLE_PREFSプロシージャ</a></li>
</ul>


<h2>カーソルを無効にしない統計情報の取得</h2>

<p>カーソルを無効化せずに統計情報を取得する。
方法としては、以下の2つがある。</p>

<ol>
<li><code>DBMS_STATS.GATHER_TABLE_STATS</code> プロシージャ実行時に指定する方法</li>
<li><code>SET_*_PREFS</code> プロシージャによりデフォルト値を変更する方法</li>
</ol>


<h2><code>DBMS_STATS.GATHER_TABLE_STATS</code> プロシージャ実行時に指定する方法</h2>

<p><code>DBMS_STATS.GATHER_TABLE_STATS</code> 実行時に指定する場合は、<code>no_invalidate</code> パラメータを <code>TRUE</code> にする。</p>

<pre><code>SQL&gt; EXEC DBMS_STATS.GATHER_TABLE_STATS('scott', 'emp', no_invalidate =&gt; TRUE);

PL/SQL procedure successfully completed.
</code></pre>

<h2><code>SET_*_PREFS</code> プロシージャによりデフォルト値を変更する方法</h2>

<p>表単位でデフォルト値を変更する場合は <code>SET_TABLE_PREFS</code> プロシージャを使う。</p>

<p><code>GET_PREFS</code> プロシージャで現在の設定の確認。</p>

<pre><code>SQL&gt; SELECT DBMS_STATS.GET_PREFS('NO_INVALIDATE', 'scott', 'emp') FROM DUAL;

DBMS_STATS.GET_PREFS('NO_INVALIDATE','SCOTT','EMP')
---------------------------------------------------
DBMS_STATS.AUTO_INVALIDATE
</code></pre>

<p><code>SET_TABLE_PREFS</code> プロシージャにて設定の変更。</p>

<pre><code>SQL&gt; EXEC DBMS_STATS.SET_TABLE_PREFS('scott', 'emp', 'NO_INVALIDATE', 'TRUE');

PL/SQL procedure successfully completed.
</code></pre>

<p><code>GET_PREFS</code> プロシージャで設定が変更されたことを確認。</p>

<pre><code>SQL&gt; SELECT DBMS_STATS.GET_PREFS('NO_INVALIDATE', 'scott', 'emp') FROM DUAL;

DBMS_STATS.GET_PREFS('NO_INVALIDATE','SCOTT','EMP')
---------------------------------------------------
TRUE
</code></pre>

<p>あとは <code>no_invalidate</code> オプションを明示的に指定せずに統計情報を採取すると変更した内容がデフォルトとして採用される。</p>

<pre><code>SQL&gt; EXEC DBMS_STATS.GATHER_TABLE_STATS('scott', 'emp');

PL/SQL procedure successfully completed.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 複数列の統計]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-multicolumn-statistics/"/>
    <updated>2012-09-16T20:21:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-multicolumn-statistics</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>相関のある複数列を列グループとして統計情報採取することでよりよい実行計画となるようにする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
-> 13 オプティマイザ統計の管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/stats.htm#CIHFICCB">13.3.1.6 複数列の統計</a></li>
</ul>


<h2>複数列の統計収集</h2>

<p>相関のある複数列を列グループとして統計情報を採取することで、オプティマイザが個々の列でなく列グループとして実行計画を計算するようにする。</p>

<ul>
<li>検証で使用する表の作成</li>
</ul>


<p>C1 列、C2 列が同じになる(つまり相関がある)ような表を作成する。</p>

<pre><code>SQL&gt; CREATE TABLE multi_col_tab (c1 NUMBER, c2 NUMBER);

Table created.

SQL&gt; BEGIN
       FOR i IN 1..5 LOOP
         FOR j IN 1..100 LOOP
           INSERT INTO multi_col_tab VALUES(i, i);
         END LOOP;
       END LOOP;
       COMMIT;
     END;
     /

PL/SQL procedure successfully completed.
</code></pre>

<p>1 〜 5 までそれぞれ 100 行ずつ、計 500 行を INSERT。</p>

<ul>
<li>複数列統計を採取しない場合</li>
</ul>


<p>複数列統計を採取しない場合の実行計画</p>

<pre><code>SQL&gt; BEGIN
       DBMS_STATS.GATHER_TABLE_STATS(null,'MULTI_COL_TAB',
         METHOD_OPT =&gt; 'FOR ALL COLUMNS SIZE SKEWONLY');
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; set autotrace on
SQL&gt; SELECT COUNT(*) FROM multi_col_tab WHERE c1 = 1 AND c2 = 1;


  COUNT(*)
----------
       100


Execution Plan
----------------------------------------------------------
Plan hash value: 610516676

------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |    20 |   120 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("C1"=1 AND "C2"=1)


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          6  consistent gets
          0  physical reads
          0  redo size
        526  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>実行計画の <code>MULTI_COL_TAB</code> の出力行に注目</p>

<pre><code>------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |    20 |   120 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------
</code></pre>

<p><code>Rows</code> が 20 となっている。
条件が <code>WHERE c1 = 1 AND c2 = 1</code> だが、相関があることを知らないので、選択行が <code>500行 * 1/5(c1 の選択率) * 1/5(c2 の選択率)</code> = 20行 となっていて正確でない。</p>

<ul>
<li>複数列統計を採取した場合</li>
</ul>


<p>複数列統計を採取する。<code>c1</code> および <code>c2</code> 列で構成させる列グループを追加して、統計情報取得。</p>

<pre><code>SQL&gt; DECLARE
       cg_name varchar2(30);
     BEGIN
       cg_name := dbms_stats.create_extended_stats(null,'multi_col_tab',  
                 '(c1,c2)');
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; BEGIN
       DBMS_STATS.GATHER_TABLE_STATS(null,'MULTI_COL_TAB',
         METHOD_OPT =&gt; 'FOR ALL COLUMNS SIZE SKEWONLY');
     END;
     /

PL/SQL procedure successfully completed.
</code></pre>

<p>なお、<code>DBMS_STATS.CREATE_EXTENDED_STATS</code> で明示的に列グループを作成しない場合は、以下のように統計情報収集時に <code>METHOD_OPT</code> で複数列を指定してもよい。</p>

<pre><code>SQL&gt; BEGIN
       DBMS_STATS.GATHER_TABLE_STATS(null,'MULTI_COL_TAB',
         METHOD_OPT =&gt; 'FOR ALL COLUMNS SIZE SKEWONLY FOR COLUMNS (C1,C2) SIZE SKEWONLY');
     END;
     /

PL/SQL procedure successfully completed.
</code></pre>

<p>先ほどと同じ SQL で実行計画を確認してみる。</p>

<pre><code>SQL&gt; set autotrace on
SQL&gt; SELECT COUNT(*) FROM multi_col_tab WHERE c1 = 1 AND c2 = 1;

  COUNT(*)
----------
       100


Execution Plan
----------------------------------------------------------
Plan hash value: 610516676

------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |   100 |   600 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("C1"=1 AND "C2"=1)


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          6  consistent gets
          0  physical reads
          0  redo size
        526  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>実行計画の <code>MULTI_COL_TAB</code> の出力行に注目</p>

<pre><code>------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |   100 |   600 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------
</code></pre>

<p><code>Rows</code> が 100 となっている。
条件が <code>WHERE c1 = 1 AND c2 = 1</code> で相関があることを認識して正確に 100 行と計算している。</p>

<ul>
<li>複数列統計の確認</li>
</ul>


<p>拡張統計として、複数列が認識されていることを確認。</p>

<pre><code>SQL&gt; col extension_name for a30
     col extension for a30
SQL&gt; Select extension_name, extension 
     from user_stat_extensions 
     where table_name='MULTI_COL_TAB';

EXTENSION_NAME                 EXTENSION
------------------------------ ------------------------------
SYS_STUF3GLKIOP5F4B0BTTCFTMX0W ("C1","C2")
</code></pre>

<p>実際に複数列の統計が採られていることを確認</p>

<pre><code>SQL&gt; col col_group for a30
SQL&gt; select e.extension col_group, t.num_distinct, t.histogram
     from user_stat_extensions e, user_tab_col_statistics t
     where e.extension_name=t.column_name
     and e.table_name=t.table_name
     and t.table_name='MULTI_COL_TAB';

COL_GROUP                      NUM_DISTINCT HISTOGRAM
------------------------------ ------------ ---------------------------------------------
("C1","C2")                               5 FREQUENCY
</code></pre>

<p><code>HISTGRAM</code> 列が <code>NONE</code> 以外であればヒストグラムが採られている。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 結果キャッシュ]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-result-cache/"/>
    <updated>2012-09-16T18:40:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-result-cache</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>&#8220;結果キャッシュ&#8221; 機能を使用する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
-> 7 メモリーの構成および使用方法<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/memory.htm#BGBCABED">7.6 サーバーおよびクライアントの結果キャッシュの管理</a></li>
</ul>


<h2>結果キャッシュの使用</h2>

<p>&#8220;結果キャッシュ&#8221; 機能を使用することで、問い合わせ結果を再利用してパフォーマンスを向上させることができる。</p>

<ul>
<li>初期化パラメータの設定</li>
</ul>


<p>結果キャッシュを有効にするためには初期化パラメータ <code>RESULT_CACHE_MAX_SIZE</code> を 0 より大きくする必要がある。</p>

<p>0 の場合は結果キャッシュは無効となる。(以下のように <code>DBMS_RESULT_CACHE.STATUS</code> の結果が <code>DISABLED</code> となっている。)</p>

<pre><code>SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       0
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
DISABLED
</code></pre>

<p>初期化パラメータ <code>RESULT_CACHE_MAX_SIZE</code> は以下のように動的に変更できるが、実際はインスタンスを再起動しないと有効にならなかった。</p>

<pre><code>SQL&gt; ALTER SYSTEM SET result_cache_max_size = 15M SCOPE=both;

System altered.

SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       15M
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
DISABLED
</code></pre>

<p>インスタンスを再起動すると、有効になり、<code>DBMS_RESULT_CACHE.STATUS</code> も <code>ENABLED</code> に変わる。</p>

<pre><code>SQL&gt; shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL&gt; startup
ORACLE instance started.

Total System Global Area  835104768 bytes
Fixed Size                  2232960 bytes
Variable Size             734006656 bytes
Database Buffers           92274688 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.
SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       15M
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
ENABLED
</code></pre>

<ul>
<li>結果キャッシュの使用</li>
</ul>


<p>結果キャッシュを使用するには <code>/*+ RESULT_CACHE */</code> ヒントを付与して問い合わせを実行すればよい。</p>

<pre><code>SQL&gt; SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp;
</code></pre>

<ul>
<li>結果キャッシュの確認</li>
</ul>


<p>実行計画で、<code>RESULT CACHE</code> と出ていると結果キャッシュが使われている。</p>

<pre><code>SQL&gt; set lines 200
SQL&gt; set autotrace on
SQL&gt; SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp;

  AVG(SAL)
----------
2083.21429


Execution Plan
----------------------------------------------------------
Plan hash value: 2083865914

--------------------------------------------------------------------------------------------------
| Id  | Operation           | Name                       | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |                            |     1 |     4 |     3   (0)| 00:00:01 |
|   1 |  RESULT CACHE       | 4z1ag1pqa9zqm704zf4nuj9tq4 |       |       |            |          |
|   2 |   SORT AGGREGATE    |                            |     1 |     4 |            |          |
|   3 |    TABLE ACCESS FULL| EMP                        |    14 |    56 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------

Result Cache Information (identified by operation id):
------------------------------------------------------

   1 - column-count=1; dependencies=(SCOTT.EMP); attributes=(single-row); name="SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp"


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          0  consistent gets
          0  physical reads
          0  redo size
        545  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>また、<code>V$RESULT_CACHE_OBJECTS</code> からも結果キャッシュについて確認できる。</p>

<pre><code>SQL&gt; SELECT type, status, name FROM v$result_cache_objects;

TYPE                           STATUS
------------------------------ ---------------------------
NAME
--------------------------------------------------------------------------------
Dependency                     Published
SCOTT.EMP

Result                         Published
SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] フラッシュバック・データ・アーカイブ(Oracle Total Recall)]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-flashback-data-archive-oracle-total-recall/"/>
    <updated>2012-09-16T17:16:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-flashback-data-archive-oracle-total-recall</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>フラッシュバック・データ・アーカイブ(Oracle Total Recall) を使用して、表への更新履歴を長期間保存する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>アドバンスト・アプリケーション開発者ガイド<br/>
-> 12 Oracle Flashback Technologyの使用<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56259/adfns_flashback.htm#BJFFDCEH">フラッシュバック・データ・アーカイブの使用(Oracle Total Recall)</a></li>
</ul>


<h2>フラッシュバック・データ・アーカイブの使用</h2>

<p>フラッシュバック・データ・アーカイブ(Oracle Total Recall) を使用して、表への更新履歴を長期間保存できる。例えば、コンプライアンス上変更履歴を年単位で長時間保存しておく必要がある場合などに有効。</p>

<ul>
<li>フラッシュバック・データ・アーカイブの作成</li>
</ul>


<p><code>CREATE FLASHBACK ARCHIVE</code> 文を使用してフラッシュバック・データ・アーカイブを作成する。
データを1年間保持するデフォルトのフラッシュバック・データ・アーカイブ <code>fla1</code> を <code>USERS</code> 表領域に作成。
作成するには <code>FLASHBACK ARCHIVE ADMINISTER</code> システム権限を持つユーザか、SYSDBA として接続する必要がある。</p>

<pre><code>SQL&gt; connect /as sysdba
Connected.
SQL&gt; CREATE FLASHBACK ARCHIVE DEFAULT fla1 TABLESPACE users
     RETENTION 1 YEAR;

Flashback archive created.
</code></pre>

<ul>
<li>表のフラッシュバック・アーカイブの有効化</li>
</ul>


<p><code>scott.emp</code> 表のフラッシュバック・アーカイブを有効にして、フラッシュバック・データ・アーカイブ <code>fla1</code> に履歴データを格納するようにする。
<code>scott</code> スキーマに <code>fla1</code> に対する <code>FLASHBACK ARCHIVE</code> オブジェクト権限を与えて、<code>ALTER TABLE</code> 文を発行する。</p>

<pre><code>SQL&gt; connect /as sysdba
Connected.
SQL&gt; GRANT FLASHBACK ARCHIVE ON fla1 TO scott;

Grant succeeded.

SQL&gt; connect scott/tiger
Connected.
SQL&gt; ALTER TABLE scott.emp FLASHBACK ARCHIVE fla1;

Table altered.
</code></pre>

<ul>
<li>フラッシュバック・データ・アーカイブが有効になっていることの確認</li>
</ul>


<p><code>scott</code> スキーマで <code>emp</code> 表のフラッシュバック・データ・アーカイブが有効になっていることの確認</p>

<pre><code>SQL&gt; connect scott/tiger
Connected.
SQL&gt; col table_name for a30
     col owner_name for a30
     col flashback_archive_name for a30
     col archive_table_name for a30
     col status for a10
     set lines 200
SQL&gt; SELECT * FROM USER_FLASHBACK_ARCHIVE_TABLES;

TABLE_NAME                     OWNER_NAME                     FLASHBACK_ARCHIVE_NAME         ARCHIVE_TABLE_NAME             STATUS
------------------------------ ------------------------------ ------------------------------ ------------------------------ ----------
EMP                            SCOTT                          FLA1                           SYS_FBA_HIST_75335             ENABLED
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 時間隔パーティション表]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-interval-partitioned-table/"/>
    <updated>2012-09-16T16:46:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-interval-partitioned-table</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>時間隔パーティション表を作成する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>VLDBおよびパーティショニング・ガイド<br/>
-> 4 パーティションの管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56316/part_admin001.htm#BAJHFFBE">時間隔パーティション表の作成</a></li>
</ul>


<h2>時間隔パーティション表の作成</h2>

<p>時間隔パーティション表はレンジ・パーティションの一種で、例えば月単位の時間隔パーティション表を作成すると、パーティションを明示的に作成しなくても自動で必要な月のパーティションをデータ insert 時に作成してくれる。</p>

<p><code>DATE</code> 型の <code>time_id</code> をパーティション・キーとして、2009年までは年単位でパーティション化し、2010年1月1日以降は月単位でパーティションを自動作成するような時間隔パーティション表を作成してみる。</p>

<pre><code>SQL&gt; CREATE TABLE interval_sales
         ( prod_id        NUMBER(6)
         , cust_id        NUMBER
         , time_id        DATE
         , channel_id     CHAR(1)
         , promo_id       NUMBER(6)
         , quantity_sold  NUMBER(3)
         , amount_sold    NUMBER(10,2)
         ) 
       PARTITION BY RANGE (time_id) 
       INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
         ( PARTITION p0 VALUES LESS THAN (TO_DATE('1-1-2008', 'DD-MM-YYYY')),
           PARTITION p1 VALUES LESS THAN (TO_DATE('1-1-2009', 'DD-MM-YYYY')),
           PARTITION p2 VALUES LESS THAN (TO_DATE('1-1-2010', 'DD-MM-YYYY')) );

Table created.
</code></pre>

<p>ちなみに追加されるパーティションを日単位にする場合は、<code>NUMTODSINTERVAL(1, 'DAY')</code> 関数を利用する。</p>

<p>パーティション情報の確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col partitioning_type for a20
     set lines 200
SQL&gt; SELECT table_name, partitioning_type FROM user_part_tables;

TABLE_NAME                     PARTITIONING_TYPE   
------------------------------ --------------------
INTERVAL_SALES                 RANGE

SQL&gt; col partition_name for a30
SQL&gt; SELECT table_name, partition_name, high_value FROM user_tab_partitions ORDER BY table_name, partition_position;

TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE
------------------------------ ------------------------------ --------------------------------------------------------------------------------
INTERVAL_SALES                 P0                             TO_DATE(' 2008-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P1                             TO_DATE(' 2009-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P2                             TO_DATE(' 2010-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
</code></pre>

<p>最初はパーティションは作られていないが、上記の範囲を超える行を insert するとパーティションが自動で作成される。</p>

<pre><code>SQL&gt; INSERT INTO interval_sales(prod_id, time_id) VALUES(1, TO_DATE('2012-09-16', 'YYYY-MM-DD'));

1 row created.

SQL&gt; COMMIT;

Commit complete.

SQL&gt; SELECT table_name, partition_name, high_value FROM user_tab_partitions ORDER BY table_name, partition_position;

TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE
------------------------------ ------------------------------ --------------------------------------------------------------------------------
INTERVAL_SALES                 P0                             TO_DATE(' 2008-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P1                             TO_DATE(' 2009-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P2                             TO_DATE(' 2010-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 SYS_P41                        TO_DATE(' 2012-10-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
</code></pre>

<p><code>SYS_P41</code> というパーティションが自動で作成された。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 参照パーティション表]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-reference-partitioned-table/"/>
    <updated>2012-09-16T16:13:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-reference-partitioned-table</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>参照パーティション表を作成する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>VLDBおよびパーティショニング・ガイド<br/>
-> 4 パーティションの管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56316/part_admin001.htm#BAJDDEEC">参照パーティション表の作成</a></li>
</ul>


<h2>参照パーティション表の作成</h2>

<p>参照パーティション表は、例えば次のようなケースで役立つ。注文を管理する orders 表に注文日が格納される order_date 列がある。また、注文に含まれる品目を管理する order_items 表があり、orders 表を order_id 列で外部参照しているとする。orders 表が order_date 列をキー値としてパーティション化されている場合、order_items 表も同じように注文日によりパーティション化したかったら、従来ならば order_date 列を order_itmes 表にも加える必要があった。参照パーティション表を使えば、order_items 列に余計な order_date 列を加えることなく、外部参照している orders と同じ単位でパーティション化することができる。</p>

<p>実際に上記シナリオで参照パーティション表を作成してみる。</p>

<pre><code>SQL&gt; CREATE TABLE orders
         ( order_id           NUMBER(12),
           order_date         DATE,
           order_mode         VARCHAR2(8),
           customer_id        NUMBER(6),
           order_status       NUMBER(2),
           order_total        NUMBER(8,2),
           sales_rep_id       NUMBER(6),
           promotion_id       NUMBER(6),
           CONSTRAINT orders_pk PRIMARY KEY(order_id)
         )
       PARTITION BY RANGE(order_date)
         ( PARTITION Q1_2005 VALUES LESS THAN (TO_DATE('01-APR-2005','DD-MON-YYYY')),
           PARTITION Q2_2005 VALUES LESS THAN (TO_DATE('01-JUL-2005','DD-MON-YYYY')),
           PARTITION Q3_2005 VALUES LESS THAN (TO_DATE('01-OCT-2005','DD-MON-YYYY')),
           PARTITION Q4_2005 VALUES LESS THAN (TO_DATE('01-JAN-2006','DD-MON-YYYY'))
         );

Table created.

SQL&gt; CREATE TABLE order_items
         ( order_id           NUMBER(12) NOT NULL,
           line_item_id       NUMBER(3)  NOT NULL,
           product_id         NUMBER(6)  NOT NULL,
           unit_price         NUMBER(8,2),
           quantity           NUMBER(8),
           CONSTRAINT order_items_fk
           FOREIGN KEY(order_id) REFERENCES orders(order_id)
         )
         PARTITION BY REFERENCE(order_items_fk);

Table created. 
</code></pre>

<p>パーティション情報の確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col partitioning_type for a20
     col ref_ptn_constraint_name for a30
     set lines 200
SQL&gt; SELECT table_name, partitioning_type, ref_ptn_constraint_name FROM user_part_tables;

TABLE_NAME                     PARTITIONING_TYPE    REF_PTN_CONSTRAINT_NAME
------------------------------ -------------------- ------------------------------
ORDERS                         RANGE
ORDER_ITEMS                    REFERENCE            ORDER_ITEMS_FK

SQL&gt; col partition_name for a30
SQL&gt; SELECT table_name, partition_name, high_value FROM user_tab_partitions ORDER BY table_name, partition_position;

TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE
------------------------------ ------------------------------ --------------------------------------------------------------------------------
ORDERS                         Q1_2005                        TO_DATE(' 2005-04-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDERS                         Q2_2005                        TO_DATE(' 2005-07-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDERS                         Q3_2005                        TO_DATE(' 2005-10-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDERS                         Q4_2005                        TO_DATE(' 2006-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDER_ITEMS                    Q1_2005
ORDER_ITEMS                    Q2_2005
ORDER_ITEMS                    Q3_2005
ORDER_ITEMS                    Q4_2005
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] BasicFiles LOB から SecureFiles LOB への移行]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-securefiles-lob/"/>
    <updated>2012-09-16T14:15:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-securefiles-lob</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>従来型の LOB (BasicFiles LOB) から、Oracle Database 11g からの新しい LOB アーキテクチャである SecureFiles を使用した LOB へ移行する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li><p>SecureFilesおよびラージ・オブジェクト開発者ガイド<br/>
-> 4 Oracle SecureFiles LOBの使用<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#BABDIEGE">BasicFiles LOBからSecureFiles LOBへの列の移行</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#BABJFEBB">SecureFiles LOBの初期化パラメータdb_securefile</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#CIHGHEFA">SecureFiles LOBを含んだCREATE TABLEの使用</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#CIHJJBIJ">SecureFiles LOBを含んだALTER TABLEの使用</a></p></li>
<li><p>管理者ガイド<br/>
-> 20 表の管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56301/tables007.htm#i1006754">表のオンライン再定義</a></p></li>
</ul>


<h2>BasicFiles LOB から SecureFiles LOB への移行</h2>

<p>Oracle Database 11g からの新しい LOB アーキテクチャである SecureFiles を使用した LOB を使用すると、以下のようなことが可能になる。</p>

<ul>
<li>圧縮(LOB データの圧縮)</li>
<li>重複除外(列内で重複する LOB データのコピーを1つのみ格納)</li>
<li>暗号化(透過的データ暗号化により LOB データを暗号化)</li>
</ul>


<p>従来型の LOB は、BasicFiles と呼ばれる。BasicFiles を使用した既存の LOB 列を SecureFiles に移行する。<code>ALTER TABLE</code> での BasicFiles から SecureFiles への変更はできないため、変更するためには表の再作成を行うか、オンライン再定義を行う必要がある。今回は、マニュアルに例があるように、オンライン再定義により行う。</p>

<ul>
<li>検証用に BasicFiles LOB 列を持つ表、データを準備</li>
</ul>


<p>BasicFiles LOB 列を持つ <code>cust</code> 表を作成してデータを insert。今回この表を SecureFiles LOB に移行してみる。</p>

<pre><code>SQL&gt; connect scott/tiger
SQL&gt; CREATE TABLE cust
     (
       c_id  NUMBER PRIMARY KEY,
       c_zip NUMBER,
       c_name VARCHAR(30) DEFAULT NULL,
       c_lob CLOB
     );

Table created.

SQL&gt; INSERT INTO cust VALUES(1, 94065, 'hhh', 'ttt');

1 row created.

SQL&gt; COMMIT;

Commit complete.
</code></pre>

<ul>
<li>オンライン再定義に必要な権限の付与</li>
</ul>


<p>オンライン再定義に必要な権限を与える</p>

<pre><code>SQL&gt; connect /as sysdba
SQL&gt; -- Grant privileges required for online redefinition.
SQL&gt; GRANT EXECUTE ON DBMS_REDEFINITION TO scott;
SQL&gt; GRANT ALTER ANY TABLE TO scott;
SQL&gt; GRANT DROP ANY TABLE TO scott;
SQL&gt; GRANT LOCK ANY TABLE TO scott;
SQL&gt; GRANT CREATE ANY TABLE TO scott;
SQL&gt; GRANT SELECT ANY TABLE TO scott;
SQL&gt; -- Privileges required to perform cloning of dependent objects.
SQL&gt; GRANT CREATE ANY TRIGGER TO scott;
SQL&gt; GRANT CREATE ANY INDEX TO scott;
</code></pre>

<ul>
<li>初期化パラメータ <code>db_securefile</code> パラメータの変更</li>
</ul>


<p>SecureFiles LOB の初期化パラメータ <code>db_securefile</code> パラメータを変更する。
SecureFiles LOB を使用するためには <code>PERMITTED</code> (デフォルト) または <code>ALWAYS</code> である必要がある。</p>

<p>例えば、<code>NEVER</code> に設定されている場合に SecureFiles LOB の列を作成しようとすると、<code>ORA-43856</code> が発生する。</p>

<pre><code>SQL&gt; CREATE TABLE test_lob (c_lob CLOB) LOB(c_lob) STORE AS SECUREFILE (compress high);
CREATE TABLE test_lob (c_lob CLOB) LOB(c_lob) STORE AS SECUREFILE (compress high)
*
ERROR at line 1:
ORA-43856: Unsupported LOB type for SECUREFILE LOB operation
</code></pre>

<p><code>db_securefile</code> を <code>ALTER SYSTEM</code> で変更する。</p>

<pre><code>SQL&gt; conn /as sysdba
Connected.
SQL&gt; ALTER SYSTEM SET db_securefile = PERMITTED SCOPE=both;

System altered.
</code></pre>

<ul>
<li>仮表を作成</li>
</ul>


<p>オンライン再定義のための仮表を SecureFiles LOB 列を持つようにして作成。元表からコピーされるので主キーなどの制約の指定は不要。</p>

<pre><code>SQL&gt; connect scott/tiger
Connected.
SQL&gt; CREATE TABLE cust_int
     (
       c_id  NUMBER,
       c_zip NUMBER,
       c_name VARCHAR(30) DEFAULT NULL,
       c_lob CLOB
     )
     LOB(c_lob) STORE AS SECUREFILE;

Table created.
</code></pre>

<ul>
<li>表のオンライン再定義</li>
</ul>


<p>表のオンライン再定義を実行する。</p>

<pre><code>SQL&gt; DECLARE
       col_mapping VARCHAR2(1000);
     BEGIN
       -- map all the columns in the interim table to the original table
       col_mapping :=
         'c_id c_id , '||
         'c_zip c_zip , '||
         'c_name c_name, '||
         'c_lob c_lob';
       DBMS_REDEFINITION.START_REDEF_TABLE('scott', 'cust', 'cust_int', col_mapping);
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; set serveroutput on
SQL&gt; DECLARE
       error_count pls_integer := 0;
     BEGIN
       DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS('scott', 'cust', 'cust_int',
         1, TRUE,TRUE,TRUE,FALSE, error_count);
       DBMS_OUTPUT.PUT_LINE('errors := ' || TO_CHAR(error_count));
     END;
     /
errors := 0

PL/SQL procedure successfully completed.

SQL&gt; EXEC DBMS_REDEFINITION.FINISH_REDEF_TABLE('scott', 'cust', 'cust_int');

PL/SQL procedure successfully completed.

SQL&gt; DROP TABLE cust_int;

Table dropped.
</code></pre>

<ul>
<li>SecureFiles LOB に移行されたことを確認</li>
</ul>


<p><code>USER_LOBS.SECUREFILE</code> 列が <code>YES</code> であれば SecureFiles になっている。</p>

<pre><code>SQL&gt; col table_name for a30
SQL&gt; col column_name for a30
SQL&gt; SELECT table_name, column_name, securefile FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    SECUREFIL
------------------------------ ------------------------------ ---------
CUST                           C_LOB                          YES
</code></pre>

<h2>SecureFiles LOB の変更</h2>

<p><code>ALTER TABLE</code> 文により既存の SecureFiles LOB 列を変更して、圧縮や重複除外の設定を行う。</p>

<ul>
<li>現在の設定の確認</li>
</ul>


<p><code>USER_LOBS</code> にて確認できる。</p>

<pre><code>SQL&gt; col table_name for a30
     col column_name for a30
     col encrypt for a10
     col compression for a15
     col deduplication for a15
     set lines 200
SQL&gt; SELECT table_name, column_name, encrypt, compression, deduplication FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    ENCRYPT    COMPRESSION     DEDUPLICATION
------------------------------ ------------------------------ ---------- --------------- ---------------
CUST                           C_LOB                          NO         NO              NO
</code></pre>

<ul>
<li>設定の変更</li>
</ul>


<p><code>ALTER TABLE</code> により圧縮、重複除外の設定を行う。</p>

<pre><code>SQL&gt; ALTER TABLE cust MODIFY LOB(c_lob) (COMPRESS HIGH);

Table altered.

SQL&gt; ALTER TABLE cust MODIFY LOB(c_lob) (DEDUPLICATE);

Table altered.
</code></pre>

<ul>
<li>設定変更の確認</li>
</ul>


<p><code>USER_LOBS</code> にて確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col column_name for a30
     col encrypt for a10
     col compression for a15
     col deduplication for a15
     set lines 200
SQL&gt; SELECT table_name, column_name, encrypt, compression, deduplication FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    ENCRYPT    COMPRESSION     DEDUPLICATION
------------------------------ ------------------------------ ---------- --------------- ---------------
CUST                           C_LOB                          NO         HIGH            LOB
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] スター型変換の使用]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/13/oracle-star-transformation/"/>
    <updated>2012-09-13T01:14:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/13/oracle-star-transformation</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>スター型変換を行い、スター・クエリーをチューニングする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>データ・ウェアハウス・ガイド<br/>
-> 20 スキーマのモデリング化技法<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/schemas.htm#CIHGHEFB">スター・クエリーの最適化</a></li>
</ul>


<h2>スター型変換を使用したスター・クエリーのチューニング</h2>

<p>スター型変換を行い、スター・クエリーをチューニングする。
スター・クエリーは1つの大規模なファクト表と、複数の小規模なディメンション表を結合するようなクエリー。ファクト表が大きいため、ファクト表をなるべく条件を絞り込んだ後でアクセスするような特別な結合(スター結合)をしたほうが効率がよい。このために暗黙的に SQL をリライト(または変換)する機能をスター型変換という。</p>

<p>スター型変換を行うためには、以下に従う必要がある。</p>

<ol>
<li>ビットマップ索引をファクト表の各外部キー列上に作成する必要がある。</li>
<li>初期化パラメータ <code>STAR_TRANSFORMATION_ENABLED</code> を <code>TRUE</code> に設定する必要がある。</li>
</ol>


<p>検証してみる。</p>

<ul>
<li>表、データを準備</li>
</ul>


<p>ディメンション表 <code>jobs</code>, <code>dates</code>, ファクト表 <code>emp_fact</code> を作成</p>

<pre><code>$ sqlplus scott/tiger
SQL&gt; -- ディメンション表 jobs
SQL&gt; CREATE TABLE jobs
     AS SELECT rownum job_id, job
     FROM (SELECT DISTINCT job FROM emp);

Table created.

SQL&gt; ALTER TABLE jobs ADD (CONSTRAINT jobs_pk PRIMARY KEY (job_id) VALIDATE);

Table altered.

SQL&gt; -- ディメンション表 dates
SQL&gt; CREATE TABLE dates
     AS SELECT rownum date_id, hiredate, to_char(hiredate, 'YYYY') year
     FROM (SELECT DISTINCT hiredate FROM emp);

Table created.

SQL&gt; ALTER TABLE dates ADD (CONSTRAINT dates_pk PRIMARY KEY (date_id) VALIDATE);

Table altered.

SQL&gt; -- ファクト表 emp_fact
SQL&gt; CREATE TABLE emp_fact
     AS SELECT e.empno, e.ename, j.job_id, e.mgr, d.date_id, e.sal, e.comm, e.deptno
     FROM emp e, dates d, jobs j
     WHERE e.job = j.job AND e.hiredate = d.hiredate;

Table created.

SQL&gt; ALTER TABLE emp_fact ADD (CONSTRAINT emp_fact_jobs_fk FOREIGN KEY(job_id) REFERENCES jobs(job_id) VALIDATE);

Table altered.

SQL&gt; ALTER TABLE emp_fact ADD (CONSTRAINT emp_fact_dates_fk FOREIGN KEY(date_id) REFERENCES dates(date_id) VALIDATE);

Table altered.

SQL&gt; -- データロード
SQL&gt; INSERT INTO emp_fact SELECT * FROM emp_fact;

14 rows created.

SQL&gt; /

28 rows created.
...(以下繰り返す)

SQL&gt; /

114688 rows created.

SQL&gt; COMMIT;

Commit complete.

SQL&gt; -- 統計情報取得
SQL&gt; EXEC DBMS_STATS.GATHER_SCHEMA_STATS('scott');

PL/SQL procedure successfully completed.
</code></pre>

<ul>
<li>スター変換の確認方法</li>
</ul>


<p>スター変換されているかどうかは <code>set autotrace trace exp</code> 等の実行計画から確認する。
例えば <code>set autotrace trace exp</code> で <code>Note</code> に以下の出力があればスター変換されている。</p>

<pre><code>Note 
-----
   - star transformation used for this statement
</code></pre>

<p>ちなみに <code>set autotrace</code> を使用するためには <code>PLUSTRACE</code> ロールが必要で、以下のように作成する。</p>

<pre><code>SQL&gt; connect /as sysdba              
Connected.
SQL&gt; @?/sqlplus/admin/plustrce.sql

SQL&gt; GRANT plustrace TO scott;

Grant succeeded.
</code></pre>

<ul>
<li>スター変換なしの場合</li>
</ul>


<p>以下の SELECT 文で試してみる。</p>

<pre><code>SQL&gt; set timing on
SQL&gt; set autotrace on
SQL&gt; set lines 200
SQL&gt; SELECT j.job, d.year, SUM(e.sal), d.dname
     FROM emp_fact e, jobs j, dates d, dept d
     WHERE e.job_id = j.job_id
     AND   e.date_id = d.date_id
     AND   e.deptno = d.deptno
     AND   j.job = 'CLERK'
     AND   d.year in ('1980', '1987')
     GROUP BY j.job, d.year, d.dname;

JOB                         YEAR         SUM(E.SAL) DNAME
--------------------------- ------------ ---------- ------------------------------------------
CLERK                       1987           18022400 RESEARCH
CLERK                       1980           13107200 RESEARCH

Elapsed: 00:00:00.04

Execution Plan
----------------------------------------------------------
Plan hash value: 3373499036

------------------------------------------------------------------------------------
| Id  | Operation               | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT        |          |     4 |   180 |   324   (3)| 00:00:04 |
|   1 |  HASH GROUP BY          |          |     4 |   180 |   324   (3)| 00:00:04 |
|*  2 |   HASH JOIN             |          | 22938 |  1008K|   323   (2)| 00:00:04 |
|   3 |    TABLE ACCESS FULL    | DEPT     |     4 |    52 |     3   (0)| 00:00:01 |
|*  4 |    HASH JOIN            |          | 22938 |   716K|   319   (2)| 00:00:04 |
|   5 |     MERGE JOIN CARTESIAN|          |     7 |   133 |     6   (0)| 00:00:01 |
|*  6 |      TABLE ACCESS FULL  | JOBS     |     1 |    11 |     3   (0)| 00:00:01 |
|   7 |      BUFFER SORT        |          |     7 |    56 |     3   (0)| 00:00:01 |
|*  8 |       TABLE ACCESS FULL | DATES    |     7 |    56 |     3   (0)| 00:00:01 |
|   9 |     TABLE ACCESS FULL   | EMP_FACT |   229K|  2912K|   312   (2)| 00:00:04 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("E"."DEPTNO"="D"."DEPTNO")
   4 - access("E"."JOB_ID"="J"."JOB_ID" AND "E"."DATE_ID"="D"."DATE_ID")
   6 - filter("J"."JOB"='CLERK')
   8 - filter("D"."YEAR"='1980' OR "D"."YEAR"='1987')


Statistics
----------------------------------------------------------
          0  recursive calls
          1  db block gets
       1098  consistent gets
          0  physical reads
          0  redo size
        824  bytes sent via SQL*Net to client
        524  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
          2  rows processed
</code></pre>

<p>0.04 秒かかっている。</p>

<ul>
<li>スター型変換</li>
</ul>


<p>スター型変換するようにビットマップ索引を作成し、初期化パラメータ<code>ALTER SESSION SET STAR_TRANSFORMATION_ENABLED</code> を <code>TRUE</code> にして再実行する。</p>

<pre><code>SQL&gt; -- ビットマップ索引を作成
SQL&gt; CREATE BITMAP INDEX emp_fact_job_bix ON emp_fact(job_id);

Index created.

SQL&gt; CREATE BITMAP INDEX emp_fact_date_bix ON emp_fact(date_id);

Index created.

SQL&gt; CREATE BITMAP INDEX emp_fact_dept_bix ON emp_fact(deptno);

Index created.

SQL&gt; -- 統計情報採取
SQL&gt; EXEC DBMS_STATS.GATHER_SCHEMA_STATS('scott');

PL/SQL procedure successfully completed.

SQL&gt; -- 初期化パラメータ変更
SQL&gt; SQL&gt; ALTER SESSION SET STAR_TRANSFORMATION_ENABLED = TRUE

Session altered.
</code></pre>

<p>先ほどと同じ SELECT を実行する。</p>

<pre><code>SQL&gt; set timing on
SQL&gt; set autotrace on
SQL&gt; set lines 200
SQL&gt; SELECT j.job, d.year, SUM(e.sal), d.dname
     FROM emp_fact e, jobs j, dates d, dept d
     WHERE e.job_id = j.job_id
     AND   e.date_id = d.date_id
     AND   e.deptno = d.deptno
     AND   j.job = 'CLERK'
     AND   d.year in ('1980', '1987')
     GROUP BY j.job, d.year, d.dname;

JOB                         YEAR         SUM(E.SAL) DNAME
--------------------------- ------------ ---------- ------------------------------------------
CLERK                       1987           18022400 RESEARCH
CLERK                       1980           13107200 RESEARCH

Elapsed: 00:00:00.02

Execution Plan
----------------------------------------------------------
Plan hash value: 4243144607

------------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                   |     4 |   216 |   322   (1)| 00:00:04 |
|   1 |  HASH GROUP BY                   |                   |     4 |   216 |   322   (1)| 00:00:04 |
|*  2 |   HASH JOIN                      |                   |  8823 |   465K|   321   (1)| 00:00:04 |
|   3 |    TABLE ACCESS FULL             | DEPT              |     4 |    52 |     3   (0)| 00:00:01 |
|*  4 |    HASH JOIN                     |                   |  8823 |   353K|   318   (1)| 00:00:04 |
|   5 |     MERGE JOIN CARTESIAN         |                   |     3 |    57 |     6   (0)| 00:00:01 |
|*  6 |      TABLE ACCESS FULL           | JOBS              |     1 |    11 |     3   (0)| 00:00:01 |
|   7 |      BUFFER SORT                 |                   |     3 |    24 |     3   (0)| 00:00:01 |
|*  8 |       TABLE ACCESS FULL          | DATES             |     3 |    24 |     3   (0)| 00:00:01 |
|   9 |     VIEW                         | VW_ST_7A68B670    | 10587 |   227K|   311   (0)| 00:00:04 |
|  10 |      NESTED LOOPS                |                   | 10587 |   444K|   305   (0)| 00:00:04 |
|  11 |       BITMAP CONVERSION TO ROWIDS|                   | 10586 |   186K|     6   (0)| 00:00:01 |
|  12 |        BITMAP AND                |                   |       |       |            |          |
|  13 |         BITMAP MERGE             |                   |       |       |            |          |
|  14 |          BITMAP KEY ITERATION    |                   |       |       |            |          |
|* 15 |           TABLE ACCESS FULL      | JOBS              |     1 |    11 |     3   (0)| 00:00:01 |
|* 16 |           BITMAP INDEX RANGE SCAN| EMP_FACT_JOB_BIX  |       |       |            |          |
|  17 |         BITMAP MERGE             |                   |       |       |            |          |
|  18 |          BITMAP KEY ITERATION    |                   |       |       |            |          |
|* 19 |           TABLE ACCESS FULL      | DATES             |     3 |    24 |     3   (0)| 00:00:01 |
|* 20 |           BITMAP INDEX RANGE SCAN| EMP_FACT_DATE_BIX |       |       |            |          |
|  21 |       TABLE ACCESS BY USER ROWID | EMP_FACT          |     1 |    25 |   305   (1)| 00:00:04 |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("ITEM_1"="D"."DEPTNO")
   4 - access("ITEM_3"="J"."JOB_ID" AND "ITEM_2"="D"."DATE_ID")
   6 - filter("J"."JOB"='CLERK')
   8 - filter("D"."YEAR"='1980' OR "D"."YEAR"='1987')
  15 - filter("J"."JOB"='CLERK')
  16 - access("E"."JOB_ID"="J"."JOB_ID")
  19 - filter("D"."YEAR"='1980' OR "D"."YEAR"='1987')
  20 - access("E"."DATE_ID"="D"."DATE_ID")

Note
-----
   - star transformation used for this statement


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
       1075  consistent gets
          0  physical reads
          0  redo size
        824  bytes sent via SQL*Net to client
        524  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
          2  rows processed
</code></pre>

<p>今回は、<code>star transformation used for this statement</code> の出力があるようにスター型変換されており、実行時間も 0.02秒と改善されている。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] トランスポータブル表領域]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/12/oracle-transportable-tablespace/"/>
    <updated>2012-09-12T23:18:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/12/oracle-transportable-tablespace</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>トランスポータブル表領域により DB 間で表領域の移動を行う。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>管理者ガイド<br/>
-> 14 表領域の管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56301/tspaces013.htm#i1007252">データベース間で表領域をトランスポートする手順および例</a></li>
</ul>


<h2>トランスポータブル表領域</h2>

<p>マニュアルに記載の手順に従い、トランスポータブル表領域により DB 間で表領域の移動を行う。</p>

<ul>
<li>今回の検証用に表領域を作成</li>
</ul>


<p><code>tt_emp</code> 表領域を作成する。</p>

<pre><code>SQL&gt; CREATE TABLESPACE tt_emp
     DATAFILE '/u01/app/oracle/oradata/PROD1/tt_emp01.dbf'
     SIZE 10M REUSE AUTOEXTEND ON;

Tablespace created.

SQL&gt; CREATE TABLE scott.tt_emp TABLESPACE tt_emp AS SELECT * FROM scott.emp;

Table created.
</code></pre>

<ul>
<li>endianness の確認</li>
</ul>


<p>異なるプラットフォーム間で表領域のトランスポートを行う場合は endianness が異なると変換が必要になる。
endianness を確認する。</p>

<pre><code>SQL&gt; set pages 100
     col platform_name for a40
     col endian_format for a15
SQL&gt; SELECT * FROM V$TRANSPORTABLE_PLATFORM;

PLATFORM_ID PLATFORM_NAME                            ENDIAN_FORMAT
----------- ---------------------------------------- ---------------
          1 Solaris[tm] OE (32-bit)                  Big
          2 Solaris[tm] OE (64-bit)                  Big
          7 Microsoft Windows IA (32-bit)            Little
         10 Linux IA (32-bit)                        Little
          6 AIX-Based Systems (64-bit)               Big
          3 HP-UX (64-bit)                           Big
          5 HP Tru64 UNIX                            Little
          4 HP-UX IA (64-bit)                        Big
         11 Linux IA (64-bit)                        Little
         15 HP Open VMS                              Little
          8 Microsoft Windows IA (64-bit)            Little
          9 IBM zSeries Based Linux                  Big
         13 Linux x86 64-bit                         Little
         16 Apple Mac OS                             Big
         12 Microsoft Windows x86 64-bit             Little
         17 Solaris Operating System (x86)           Little
         18 IBM Power Based Linux                    Big
         19 HP IA Open VMS                           Little
         20 Solaris Operating System (x86-64)        Little
         21 Apple Mac OS (x86-64)                    Little

20 rows selected.

SQL&gt; SELECT PLATFORM_NAME FROM V$DATABASE;

PLATFORM_NAME
----------------------------------------
Linux x86 64-bit

SQL&gt; SELECT d.PLATFORM_NAME, ENDIAN_FORMAT
     FROM V$TRANSPORTABLE_PLATFORM tp, V$DATABASE d
     WHERE tp.PLATFORM_NAME = d.PLATFORM_NAME;

PLATFORM_NAME                            ENDIAN_FORMAT
---------------------------------------- ---------------
Linux x86 64-bit                         Little
</code></pre>

<ul>
<li>表領域が自己完結型かどうかの確認</li>
</ul>


<p>表領域内に別の表領域の表の索引が含まれている場合などは自己完結型でないためトランスポートできない。
表領域が自己完結型かどうかチェックする。</p>

<pre><code>SQL&gt; EXECUTE DBMS_TTS.TRANSPORT_SET_CHECK('tt_emp', TRUE);

PL/SQL procedure successfully completed.

SQL&gt; SELECT * FROM TRANSPORT_SET_VIOLATIONS;

no rows selected
</code></pre>

<p>もし、違反している場合は <code>TRANSPORT_SET_VIOLATIONS</code> ビューに違反している内容が表示される。</p>

<ul>
<li>表領域を読み取り専用にする</li>
</ul>


<p>表領域を読取り専用にする。</p>

<pre><code>SQL&gt; ALTER TABLESPACE tt_emp READ ONLY;

Tablespace altered.
</code></pre>

<ul>
<li>データ・ポンプによりエクスポート</li>
</ul>


<p><code>expdp</code> によりエクスポートする。</p>

<pre><code>$ expdp system/oracle dumpfile=expdat.dmp directory=data_pump_dir \
        transport_tablespaces=tt_emp logfile=tts_export.log

Export: Release 11.2.0.3.0 - Production on Wed Sep 12 23:53:49 2012

Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.

Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
FLASHBACK automatically enabled to preserve database integrity.
Starting "SYSTEM"."SYS_EXPORT_TRANSPORTABLE_01":  system/******** dumpfile=expdat.dmp directory=data_pump_dir transport_tablespaces=tt_emp logfile=tts_export.log 
Processing object type TRANSPORTABLE_EXPORT/PLUGTS_BLK
Processing object type TRANSPORTABLE_EXPORT/TABLE
Processing object type TRANSPORTABLE_EXPORT/POST_INSTANCE/PLUGTS_BLK
Master table "SYSTEM"."SYS_EXPORT_TRANSPORTABLE_01" successfully loaded/unloaded
******************************************************************************
Dump file set for SYSTEM.SYS_EXPORT_TRANSPORTABLE_01 is:
  /u01/app/oracle/admin/PROD1/dpdump/expdat.dmp
******************************************************************************
Datafiles required for transportable tablespace TT_EMP:
  /u01/app/oracle/oradata/PROD1/tt_emp01.dbf
Job "SYSTEM"."SYS_EXPORT_TRANSPORTABLE_01" successfully completed at 23:54:17
</code></pre>

<ul>
<li>endianness の変換</li>
</ul>


<p>もし、endianness の異なるプラットフォームにトランスポートする場合は、RMAN でデータファイルの変換を行う。</p>

<pre><code>$ export ORACLE_SID=PROD1
$ rman target /
RMAN&gt; CONVERT TABLESPACE tt_emp
      TO PLATFORM 'Apple Mac OS'
      FORMAT '/tmp/%U';

Starting conversion at source at 12-09-12
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=43 device type=DISK
channel ORA_DISK_1: starting datafile conversion
input datafile file number=00006 name=/u01/app/oracle/oradata/PROD1/tt_emp01.dbf
converted datafile=/tmp/data_D-PROD1_I-2014160803_TS-TT_EMP_FNO-6_07nl25cg
channel ORA_DISK_1: datafile conversion complete, elapsed time: 00:00:01
Finished conversion at source at 12-09-12  
</code></pre>

<ul>
<li>表領域のデータファイルと、エクスポート・ダンプ・ファイルをトランスポート先に移動</li>
</ul>


<p>今回は同一サーバ上の別 DB にした。</p>

<pre><code># エクスポート・ダンプ・ファイル をトランスポート先 DB の DATA_PUMP_DIR にコピー
$ cp -i /u01/app/oracle/admin/PROD1/dpdump/expdat.dmp /u01/app/oracle/admin/PROD2/dpdump/

# 通常はデータファイルをトランスポート先のデータファイルの位置にコピー
# 今回はテストとして endianness を変換したファイルをコピーした
$ cp -i /tmp/data_D-PROD1_I-2014160803_TS-TT_EMP_FNO-6_07nl25cg /tmp/tt_emp01.dbf
</code></pre>

<ul>
<li>endianness の変換</li>
</ul>


<p>もし、endianness の異なるプラットフォームにトランスポートする場合でトランスポート元で変換を行っていない場合は、RMAN でデータファイルの変換を行う。</p>

<pre><code>$ export ORACLE_SID=PROD2
$ rman target /
RMAN&gt; CONVERT DATAFILE
      '/tmp/tt_emp01.dbf'
      TO PLATFORM 'Linux x86 64-bit'
      FROM PLATFORM 'Apple Mac OS'
      DB_FILE_NAME_CONVERT='/tmp/', '/u01/app/oracle/oradata/PROD2/';

Starting conversion at target at 12-09-13
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=36 device type=DISK
channel ORA_DISK_1: starting datafile conversion
input file name=/tmp/tt_emp01.dbf
converted datafile=/u01/app/oracle/oradata/PROD2/tt_emp01.dbf
channel ORA_DISK_1: datafile conversion complete, elapsed time: 00:00:01
Finished conversion at target at 12-09-13
</code></pre>

<ul>
<li>トランスポート元の表領域を読取り/書込みモードに戻す。</li>
</ul>


<p><code>ALTER TABLESPACE</code> にて戻す。</p>

<pre><code>$ export ORACLE_SID=PROD1
$ sqlplus '/as sysdba'
SQL&gt; ALTER TABLESPACE tt_emp READ WRITE;

Tablespace altered.
</code></pre>

<ul>
<li>データ・ポンプによりインポート</li>
</ul>


<p><code>impdp</code> によりインポートする。</p>

<pre><code>$ export ORACLE_SID=PROD2
$ impdp system/oracle dumpfile=expdat.dmp directory=data_pump_dir \
        transport_datafiles='/u01/app/oracle/oradata/PROD2/tt_emp01.dbf' \
        logfile=tts_import.log

Import: Release 11.2.0.3.0 - Production on Thu Sep 13 00:22:31 2012

Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.

Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
Master table "SYSTEM"."SYS_IMPORT_TRANSPORTABLE_01" successfully loaded/unloaded
Starting "SYSTEM"."SYS_IMPORT_TRANSPORTABLE_01":  system/******** dumpfile=expdat.dmp directory=data_pump_dir transport_datafiles=/u01/app/oracle/oradata/PROD2/tt_emp01.dbf logfile=tts_import.log 
Processing object type TRANSPORTABLE_EXPORT/PLUGTS_BLK
Processing object type TRANSPORTABLE_EXPORT/TABLE
Processing object type TRANSPORTABLE_EXPORT/POST_INSTANCE/PLUGTS_BLK
Job "SYSTEM"."SYS_IMPORT_TRANSPORTABLE_01" successfully completed at 00:22:34
</code></pre>

<ul>
<li>トランスポート先の表領域を読取り/書込みモードに戻す。</li>
</ul>


<p><code>ALTER TABLESPACE</code> にて戻す。</p>

<pre><code>$ export ORACLE_SID=PROD2
$ sqlplus '/as sysdba'
SQL&gt; ALTER TABLESPACE tt_emp READ WRITE;

Tablespace altered.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] マテリアライズド・ビューの高速リフレッシュ]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/12/oracle-fast-refresh-on-materialized-view/"/>
    <updated>2012-09-12T21:14:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/12/oracle-fast-refresh-on-materialized-view</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>集計(<code>AVG(sal)</code> など)や結合(<code>emp.deptno = dept.deptno</code> など)を含むマテリアライズド・ビューを高速リフレッシュ可能にする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>データ・ウェアハウス・ガイド<br/>
-> 9 基本的なマテリアライズド・ビュー<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1006519">集計を含むマテリアライズド・ビュー</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1007028">集計を含むマテリアライズド・ビューの高速リフレッシュに関する制限</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1006674">結合のみを含むマテリアライズド・ビュー</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1007013">結合のみを含むマテリアライズド・ビューの高速リフレッシュに関する制限</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#sthref257">DBMS_MVIEW.EXPLAIN_MVIEWプロシージャの使用</a></li>
</ul>


<h2>集計を含むマテリアライズド・ビュー</h2>

<p>集計(<code>AVG(sal)</code> など)を含むマテリアライズド・ビューを高速リフレッシュ可能にする。</p>

<p>マニュアルから、集計関数(<code>SUM</code>, <code>COUNT(*)</code>, <code>AVG</code> など)を含むマテリアライズド・ビューを高速リフレッシュ可能にするためにはいくつか制限がある。
ざっくり含める必要がある要件をまとめると以下。</p>

<ul>
<li><p>マテリアライズド・ビュー・ログの要件</p>

<ul>
<li>マテリアライズド・ビューで参照される列をすべて含める</li>
<li><code>ROWID</code> および <code>INCLUDING NEW VALUES</code> 句を指定</li>
<li>表の更新を行う場合は <code>SEQUENCE</code> 句を指定</li>
</ul>
</li>
<li><p>マテリアライズド・ビューの SELECT 文に含める要件</p>

<ul>
<li><code>COUNT(*)</code> を含める</li>
<li><code>AVG(expr)</code> などの集計ごとに、対応する <code>COUNT(expr)</code> および <code>SUM(expr)</code> を含める。(<a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#sthref182">集計関数によって要件は異なる</a>)</li>
</ul>
</li>
</ul>


<p>例えば以下の SELECT を含むマテリアライズド・ビューを考える。</p>

<pre><code>SELECT d.dname, AVG(e.sal) avg_sal
FROM emp e, dept d
WHERE e.deptno = d.deptno
GROUP BY d.dname;
</code></pre>

<p>高速リフレッシュ可能なマテリアライズド・ビューを作成する。</p>

<ul>
<li>マテリアライズド・ビュー・ログの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW LOG</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW LOG ON emp
     WITH SEQUENCE, ROWID
     (sal, deptno)
     INCLUDING NEW VALUES;

Materialized view log created.

SQL&gt; CREATE MATERIALIZED VIEW LOG ON dept
     WITH SEQUENCE, ROWID
     (deptno, dname)
     INCLUDING NEW VALUES;

Materialized view log created.
</code></pre>

<ul>
<li>マテリアライズド・ビューの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW emp_dept_mv
     BUILD IMMEDIATE
     REFRESH FAST
     ENABLE QUERY REWRITE
     AS SELECT d.dname, AVG(e.sal) avg_sal,
               COUNT(*) cnt, COUNT(e.sal) cnt_sal, SUM(e.sal) sum_sal
     FROM emp e, dept d
     WHERE e.deptno = d.deptno
     GROUP BY d.dname;

Materialized view created.
</code></pre>

<h2>高速リフレッシュ可能か確認する方法</h2>

<p><code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャを使用することで簡単にマテリアライズド・ビューに関して次のことを確認できる。</p>

<ul>
<li>高速リフレッシュ可能かどうか</li>
<li>実行できるクエリー・リライトのタイプ</li>
<li>PCT リフレッシュ(パーティション単位での高速リフレッシュ)が可能かどうか(パーティション表でないと意味なし)</li>
</ul>


<p>使い方は以下</p>

<ol>
<li><code>$ORACLE_HOME/rdbms/admin/utlxmv.sql</code> を流して <code>MV_CAPABILITIES_TABLE</code> 表を作成</li>
<li><code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャの引数にマテリアライズド・ビュー名かマテリアライズド・ビューで使用している SELECT 文を与えて実行</li>
<li><code>MV_CAPABILITIES_TABLE</code> 表を SELECT して確認</li>
<li>再度 <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャを実行する場合は <code>TRUNCATE TABLE MV_CAPABILITIES_TABLE</code> で結果をクリア</li>
</ol>


<p>先ほど作成したマテリアライズド・ビューで確認してみる。</p>

<pre><code>SQL&gt; @?/rdbms/admin/utlxmv.sql

Table created.

SQL&gt; EXEC DBMS_MVIEW.EXPLAIN_MVIEW('emp_dept_mv');

PL/SQL procedure successfully completed.

SQL&gt; set lines 200
     set pages 100
     col capability_name for a30
     col rel_text for a10
     col msgtxt for a60
SQL&gt; SELECT capability_name,  possible, SUBSTR(related_text,1,8)
       AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
     FROM MV_CAPABILITIES_TABLE
     ORDER BY seq;

CAPABILITY_NAME                POS REL_TEXT   MSGTXT
------------------------------ --- ---------- ------------------------------------------------------------
PCT                            N
REFRESH_COMPLETE               Y
REFRESH_FAST                   Y
REWRITE                        Y
PCT_TABLE                      N   EMP        relation is not a partitioned table
PCT_TABLE                      N   DEPT       relation is not a partitioned table
REFRESH_FAST_AFTER_INSERT      Y
REFRESH_FAST_AFTER_ONETAB_DML  Y
REFRESH_FAST_AFTER_ANY_DML     Y
REFRESH_FAST_PCT               N              PCT is not possible on any of the detail tables in the mater
REWRITE_FULL_TEXT_MATCH        Y
REWRITE_PARTIAL_TEXT_MATCH     Y
REWRITE_GENERAL                Y
REWRITE_PCT                    N              general rewrite is not possible or PCT is not possible on an
PCT_TABLE_REWRITE              N   EMP        relation is not a partitioned table
PCT_TABLE_REWRITE              N   DEPT       relation is not a partitioned table

16 rows selected.
</code></pre>

<p><code>possible</code> 列が <code>Y</code> であることから高速リフレッシュ可能であることが分かる。(<code>PCT*</code> に関してはパーティション表ではないので無視)</p>

<p>例えば、以下のようにマテリアライズド・ビュー作成前に高速リフレッシュ可能か確認でき、可能でない場合は理由を表示してくれる。</p>

<pre><code>SQL&gt; TRUNCATE TABLE MV_CAPABILITIES_TABLE;

Table truncated.

SQL&gt; -- わざと COUNT(e.sal), SUM(e.sal) を外してみる
SQL&gt; BEGIN
       DBMS_MVIEW.EXPLAIN_MVIEW('
         SELECT d.dname, AVG(e.sal) avg_sal,
                COUNT(*) cnt
         FROM emp e, dept d
         WHERE e.deptno = d.deptno
         GROUP BY d.dname');
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; SELECT capability_name,  possible, SUBSTR(related_text,1,8)
       AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
     FROM MV_CAPABILITIES_TABLE
     ORDER BY seq;

CAPABILITY_NAME                POS REL_TEXT   MSGTXT
------------------------------ --- ---------- ------------------------------------------------------------
PCT                            N
REFRESH_COMPLETE               Y
REFRESH_FAST                   N
REWRITE                        Y
PCT_TABLE                      N   EMP        relation is not a partitioned table
PCT_TABLE                      N   DEPT       relation is not a partitioned table
REFRESH_FAST_AFTER_INSERT      N   AVG_SAL    agg(expr) requires correspondng COUNT(expr) function
REFRESH_FAST_AFTER_ONETAB_DML  N              see the reason why REFRESH_FAST_AFTER_INSERT is disabled
REFRESH_FAST_AFTER_ANY_DML     N              see the reason why REFRESH_FAST_AFTER_ONETAB_DML is disabled
REFRESH_FAST_PCT               N              PCT is not possible on any of the detail tables in the mater
REWRITE_FULL_TEXT_MATCH        Y
REWRITE_PARTIAL_TEXT_MATCH     Y
REWRITE_GENERAL                Y
REWRITE_PCT                    N              general rewrite is not possible or PCT is not possible on an
PCT_TABLE_REWRITE              N   EMP        relation is not a partitioned table
PCT_TABLE_REWRITE              N   DEPT       relation is not a partitioned table

16 rows selected.
</code></pre>

<p>高速リフレッシュが不可で、<code>AVG_SAL</code> 列に関して対応する <code>COUNT(expr)</code> が必要なことを指摘してくれる。</p>

<h2>結合のみを含むマテリアライズド・ビュー</h2>

<p>集計関数は含まずに結合(<code>emp.deptno = dept.deptno</code> など)のみを含むマテリアライズド・ビューを高速リフレッシュ可能にする。</p>

<p>マニュアルから、結合のみを含むマテリアライズド・ビューを高速リフレッシュ可能にするためにはいくつか制限がある。
ざっくり含める必要がある要件をまとめると以下。</p>

<ul>
<li><p>マテリアライズド・ビュー・ログの要件</p>

<ul>
<li><code>ROWID</code> 句を指定</li>
</ul>
</li>
<li><p>マテリアライズド・ビューの SELECT 文に含める要件</p>

<ul>
<li><code>FROM</code> 内の全ての表の ROWID を含める</li>
</ul>
</li>
</ul>


<p>例えば以下の SELECT を含むマテリアライズド・ビューを考える。</p>

<pre><code>SELECT e.ename, d.loc
FROM emp e, dept d
WHERE e.deptno = d.deptno;
</code></pre>

<p>高速リフレッシュ可能なマテリアライズド・ビューを作成する。</p>

<ul>
<li>マテリアライズド・ビュー・ログの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW LOG</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW LOG ON emp
     WITH ROWID;

Materialized view log created.

SQL&gt; CREATE MATERIALIZED VIEW LOG ON dept
     WITH ROWID;

Materialized view log created.
</code></pre>

<ul>
<li>マテリアライズド・ビューの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW emp_dept_mv
     BUILD IMMEDIATE
     REFRESH FAST
     ENABLE QUERY REWRITE
     AS SELECT e.ename, d.loc,
               e.rowid e_rowid, d.rowid d_rowid
     FROM emp e, dept d
     WHERE e.deptno = d.deptno;

Materialized view created.
</code></pre>

<ul>
<li>高速リフレッシュ可能か確認</li>
</ul>


<p>先ほど行ったように <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャで確認する。</p>

<pre><code>SQL&gt; TRUNCATE TABLE MV_CAPABILITIES_TABLE;

Table truncated.

SQL&gt; EXEC DBMS_MVIEW.EXPLAIN_MVIEW('emp_dept_mv');

PL/SQL procedure successfully completed.

SQL&gt; SELECT capability_name,  possible, SUBSTR(related_text,1,8)
       AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
     FROM MV_CAPABILITIES_TABLE
     ORDER BY seq;

CAPABILITY_NAME                POS REL_TEXT   MSGTXT
------------------------------ --- ---------- ------------------------------------------------------------
PCT                            N
REFRESH_COMPLETE               Y
REFRESH_FAST                   Y
REWRITE                        Y
PCT_TABLE                      N   EMP        relation is not a partitioned table
PCT_TABLE                      N   DEPT       relation is not a partitioned table
REFRESH_FAST_AFTER_INSERT      Y
REFRESH_FAST_AFTER_ONETAB_DML  Y
REFRESH_FAST_AFTER_ANY_DML     Y
REFRESH_FAST_PCT               N              PCT is not possible on any of the detail tables in the mater
REWRITE_FULL_TEXT_MATCH        Y
REWRITE_PARTIAL_TEXT_MATCH     Y
REWRITE_GENERAL                Y
REWRITE_PCT                    N              general rewrite is not possible or PCT is not possible on an
PCT_TABLE_REWRITE              N   EMP        relation is not a partitioned table
PCT_TABLE_REWRITE              N   DEPT       relation is not a partitioned table

16 rows selected.
</code></pre>

<p><code>PCT*</code> 以外は <code>possible</code> 列が <code>Y</code> になっているので高速リフレッシュ可能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] Data Guard ファスト・スタート・フェイルオーバー]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/11/oracle-data-guard-fast-start-failover/"/>
    <updated>2012-09-11T19:54:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/11/oracle-data-guard-fast-start-failover</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>Data Guard のファスト・スタート・フェイルオーバーにより、プライマリ DB での障害発生時に自動でフェイルオーバーするようにする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
<li>EM: Oracle Enterprise Manager Grid Control 11g (11.1)</li>
</ul>


<h2>ファスト・スタート・フェイルオーバーの構成</h2>

<p>Data Guard のファスト・スタート・フェイルオーバーにより、プライマリ DB での障害発生時に自動でフェイルオーバーするようにできる。
ファスト・スタート・フェイルオーバーには、プライマリ DB、スタンバイ DB を監視する&#8221;オブザーバ&#8221;が必要。オブザーバはプライマリ DB、スタンバイ DB とは別のサーバに配置することが望ましいが、今回はスタンバイ DB と同じサーバに構成する。</p>

<p>EM Grid Control を使用してファスト・スタート・フェイルオーバーを有効にする。</p>

<ul>
<li>プライマリ DB インスタンスの &#8220;可用性&#8221; タブ内の Data Guard の項目から &#8220;設定および管理&#8221; をクリックして、Data Guard のページを開く</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-creating-a-physical-standby-database/dg-14.png" width="720" height="450"></p>

<ul>
<li>&#8220;ファスト・スタート・フェイルオーバー&#8221; の &#8220;無効&#8221; をクリック</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-1.png" width="720" height="450"></p>

<ul>
<li>&#8220;オブザーバの構成&#8221; をクリック</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-2.png" width="720" height="450"></p>

<ul>
<li>オブザーバの場所として今回はスタンバイ DB と同じサーバを指定。ORACLE_HOME の位置も入力する。</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-3.png" width="720" height="450"></p>

<ul>
<li>&#8220;続行&#8221;</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-4.png" width="720" height="450"></p>

<ul>
<li>オブザーバを起動する OS ユーザを入力</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-5.png" width="720" height="450"></p>

<ul>
<li>&#8220;続行&#8221;</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-6.png" width="720" height="450"></p>

<ul>
<li>&#8220;はい&#8221;</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-7.png" width="720" height="450"></p>

<ul>
<li>処理中 -> 完了</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-8.png" width="720" height="450"></p>

<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-9.png" width="720" height="450"></p>

<p>なぜか上記画面のまま &#8220;概要&#8221; のページに戻らない。alert.log を確認して処理が終わっていそうだったら、EM の画面を切り替えてしまってよい。</p>

<ul>
<li>Data Guard の構成画面に戻ると &#8220;ファスト・スタート・フェイルオーバー&#8221; が &#8220;stdby1.localに対して有効&#8221; になり、&#8221;オブザーバの場所&#8221; が &#8220;sv2.local&#8221; になっている。(<code>stdby1.local</code> はスタンバイ DB, <code>sv2.local</code> はオブザーバを構成したサーバで今回はスタンバイ DB と同じサーバ)</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-10.png" width="720" height="450"></p>

<h2>ファスト・スタート・フェイルオーバーの検証</h2>

<p>ファスト・スタート・フェイルオーバーが動作するか検証してみる。
<a href="http://docs.oracle.com/cd/E16338_01/server.112/b56304/sofo.htm#BCGHEJFH">マニュアル Data Guard Broker</a> によると次の場合にファスト・スタート・フェイルオーバーが試行される。</p>

<ul>
<li>プライマリ・データベースと、オブザーバおよびターゲット・スタンバイ・データベースの両方との接続が失われた場合</li>
<li>インスタンス障害</li>
<li>強制終了(ABORT オプションでの停止)</li>
</ul>


<p>正常にデータベースを停止した場合(NORMAL, IMMEDIATE, TRANSACTIONAL)では、ファスト・スタート・フェイルオーバーは試行されないので、プライマリ DB を停止するときは通常通り ABORT 以外のオプションで SHUTDOWN すればいい。</p>

<p>ファスト・スタート・フェイルオーバーを検証するためにプライマリ DB を <code>shutdown abort</code> で強制終了する。</p>

<pre><code># プライマリ側で実施
$ export ORACLE_SID=PROD1
$ sqlplus '/as sysdba'
SQL&gt; shutdown abort
ORACLE instance shut down.
</code></pre>

<p>これで、プライマリ DB の異常をオブザーバが検知して、フェイルオーバーが自動で開始される。
オブザーバは Data Guard Broker の dgmgrl コマンドで実行されているので、ログは <code>$ORACLE_HOME/rdbms/log/dgmgrl_XXXX_XXXX.log</code> に出力されている。</p>

<pre><code># オブザーバ配置サーバで実施
$ ps -ef | grep dgmgrl
oracle   12805     1  0 20:27 ?        00:00:01 /u01/app/oracle/product/11.2.0/dbhome_1/bin/dgmgrl -logfile /u01/app/oracle/product/11.2.0/dbhome_1/rdbms/log/dgmgrl_PROD1_12804.log

$ cat $ORACLE_HOME/rdbms/log/dgmgrl_PROD1_12804.log 
Observer started
[W000 09/11 20:27:30.89] Observer started.

21:07:33.37  2012年9月11日 Tuesday
Initiating Fast-Start Failover to database "stdby1"...
Performing failover NOW, please wait...
Failover succeeded, new primary is "stdby1"
21:07:35.66  2012年9月11日 Tuesday
</code></pre>

<p>これで、フェイルオーバーが実施された。EM の元スタンバイ DB 側を確認すると以下のようになっている。</p>

<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-11.png" width="720" height="450"></p>

<p>この後、元プライマリ DB を起動すると、自動でスタンバイ DB として構成してくれる。</p>

<pre><code># 元プライマリ側で実施
$ export ORACLE_SID=PROD1
$ sqlplus '/as sysdba'
SQL&gt; shutdown abort
ORACLE instance shut down.
SQL&gt; startup
ORACLE instance started.

Total System Global Area  835104768 bytes
Fixed Size                  2232960 bytes
Variable Size             511708544 bytes
Database Buffers          314572800 bytes
Redo Buffers                6590464 bytes
Database mounted.
ORA-16649: possible failover to another database prevents this database from
being opened
</code></pre>

<p>オブザーバのログを確認すると、元プライマリ DB が新たにスタンバイ DB としてマウントされたログ出力がある。</p>

<pre><code># オブザーバ配置サーバで実施
$ cat $ORACLE_HOME/rdbms/log/dgmgrl_PROD1_12804.log 
21:18:47.02  2012年9月11日 Tuesday
Initiating reinstatement for database "PROD1"...
Reinstating database "PROD1", please wait...
Operation requires shutdown of instance "PROD1" on database "PROD1"
Shutting down instance "PROD1"...
ORA-01109: database not open

Database dismounted.
ORACLE instance shut down.
Operation requires startup of instance "PROD1" on database "PROD1"
Starting instance "PROD1"...
ORACLE instance started.
Database mounted.
Continuing to reinstate database "PROD1" ...
Reinstatement of database "PROD1" succeeded
21:19:33.19  2012年9月11日 Tuesday
</code></pre>

<p>EM の元スタンバイ DB 側を確認すると以下のように元プライマリ DB が新たにスタンバイ DB として構成されていることが分かる。</p>

<p><img src="http://th0x4c.github.com/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-12.png" width="720" height="450"></p>

<p>この後、スイッチオーバすれば、元の構成に戻る。</p>

<h2>ファスト・スタート・フェイルオーバー環境でのデータベースの停止</h2>

<p><a href="http://docs.oracle.com/cd/E16338_01/server.112/b56304/sofo.htm#CHDJCDDB">マニュアル</a> に記載があるように、ファスト・スタート・フェイルオーバー環境でのデータベースの停止する場合は次のようにする。</p>

<ol>
<li><p>オブザーバを停止し、プライマリ DB およびターゲット・スタンバイ DB の両方について、V$DATABASE.FS_FAILOVER_OBSERVER_PRESENT 列が <code>NO</code> になるまで待機する。こうすると、プライマリ DB の停止中に、ファスト・スタート・フェイルオーバーは実行されない。</p></li>
<li><p>プライマリ DB およびターゲット・スタンバイ DB を停止(<code>SHUTDOWN</code>)する。</p></li>
</ol>


<p>以下が実行例。</p>

<p><code>dgmgrl</code> にてオブザーバを停止</p>

<pre><code>$ export ORACLE_SID=stdby1
$ dgmgrl
DGMGRL for Linux: Version 11.2.0.3.0 - 64bit Production

Copyright (c) 2000, 2009, Oracle. All rights reserved.

Welcome to DGMGRL, type "help" for information.
DGMGRL&gt; connect sys/oracle
Connected.
DGMGRL&gt; stop observer;
Done.
DGMGRL&gt; exit
</code></pre>

<p>プライマリ DB およびスタンバイ DB にてV$DATABASE.FS_FAILOVER_OBSERVER_PRESENT 列が <code>NO</code> になることを確認して <code>SHUTDOWN</code> する。</p>

<pre><code># プライマリ DB および スタンバイ DB でそれぞれ実施
$ sqlplus 'as sysdba'
SQL&gt; SELECT FS_FAILOVER_OBSERVER_PRESENT FROM V$DATABASE;

FS_FAILOVER_OBSERVER_
---------------------
YES

SQL&gt; /

FS_FAILOVER_OBSERVER_
---------------------
NO

SQL&gt; shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL&gt; exit
</code></pre>

<p>起動時はプライマリ DB およびスタンバイ DB を起動した後に、<code>dgmgrl</code> でオブザーバを起動(<code>start observer</code>)する。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] Data Guard 環境での RMAN の構成]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-rman-configuration/"/>
    <updated>2012-09-09T23:00:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-rman-configuration</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>Data Guard 環境での RMAN のアーカイブ・ログ削除方針を変更する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>Data Guard概要および管理<br/>
-> 11 Recovery Managerを使用したファイルのバックアップおよびリストア<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56302/rman.htm#BAJHHAEB">11.3.2 プライマリ・データベースでのRecovery Manager構成</a></li>
</ul>


<h2>Data Guard 環境での RMAN の構成</h2>

<p>Data Guard 環境での RMAN のアーカイブ・ログ削除方針を変更する。</p>

<ul>
<li>現在の設定の確認</li>
</ul>


<p>プライマリ DB をターゲットとして接続し、<code>show all</code> コマンドで現在の設定を確認</p>

<pre><code>$ export ORACLE_SID=PROD1
$ rman target /
RMAN&gt; show all;

using target database control file instead of recovery catalog
RMAN configuration parameters for database with db_unique_name PROD1 are:
CONFIGURE RETENTION POLICY TO REDUNDANCY 1; # default
CONFIGURE BACKUP OPTIMIZATION OFF; # default
CONFIGURE DEFAULT DEVICE TYPE TO DISK; # default
CONFIGURE CONTROLFILE AUTOBACKUP OFF; # default
CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '%F'; # default
CONFIGURE DEVICE TYPE DISK PARALLELISM 1 BACKUP TYPE TO BACKUPSET; # default
CONFIGURE DATAFILE BACKUP COPIES FOR DEVICE TYPE DISK TO 1; # default
CONFIGURE ARCHIVELOG BACKUP COPIES FOR DEVICE TYPE DISK TO 1; # default
CONFIGURE MAXSETSIZE TO UNLIMITED; # default
CONFIGURE ENCRYPTION FOR DATABASE OFF; # default
CONFIGURE ENCRYPTION ALGORITHM 'AES128'; # default
CONFIGURE COMPRESSION ALGORITHM 'BASIC' AS OF RELEASE 'DEFAULT' OPTIMIZE FOR LOAD TRUE ; # default
CONFIGURE ARCHIVELOG DELETION POLICY TO NONE; # default
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '/u01/app/oracle/product/11.2.0/dbhome_1/dbs/snapcf_PROD1.f'; # default
</code></pre>

<p>アーカイブ・ログの削除方針(<code>CONFIGURE ARCHIVELOG DELETION POLICY</code>)はデフォルトの <code>NONE</code> になっている。</p>

<ul>
<li>アーカイブ・ログの削除方針を変更する。</li>
</ul>


<p><code>CONFIGURE ARCHIVELOG DELETION POLICY</code> コマンドによりアーカイブ・ログの削除方針を変更する。</p>

<p>すべてのスタンバイ DB への<strong>送信(SHIPPED)</strong>を確認するまでアーカイブ・ログを削除しないようにする場合は、次のようにする。</p>

<pre><code>RMAN&gt; CONFIGURE ARCHIVELOG DELETION POLICY TO SHIPPED TO ALL STANDBY;

new RMAN configuration parameters:
CONFIGURE ARCHIVELOG DELETION POLICY TO SHIPPED TO ALL STANDBY;
new RMAN configuration parameters are successfully stored
</code></pre>

<p>すべてのスタンバイ DB への<strong>適用(APPLIED)</strong>を確認するまでアーカイブ・ログを削除しないようにする場合は、次のようにする。</p>

<pre><code>RMAN&gt; CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON ALL STANDBY;

new RMAN configuration parameters:
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON ALL STANDBY;
new RMAN configuration parameters are successfully stored
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] Data Guard リアルタイム問い合わせ]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-real-time-query/"/>
    <updated>2012-09-09T22:28:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-real-time-query</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>Data Guard の &#8220;リアルタイム問い合わせ&#8221; 機能により、REDO 適用を中断せずプライマリの更新をリアルタイムで適用しつつ、スタンバイ DB を読み取り専用でオープンする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
<li>EM: Oracle Enterprise Manager Grid Control 11g (11.1)</li>
</ul>


<h2>リアルタイム問い合わせ</h2>

<p>Data Guard の &#8220;リアルタイム問い合わせ&#8221; 機能により、REDO 適用を中断せずプライマリの更新をリアルタイムで適用しつつ、スタンバイ DB を読み取り専用でオープンすることができる。</p>

<p>今回は EM Grid Control を使用してこの機能を有効にする。</p>

<ul>
<li>プライマリ DB インスタンスの &#8220;可用性&#8221; タブ内の Data Guard の項目から &#8220;設定および管理&#8221; をクリックして、Data Guard のページを開く</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-creating-a-physical-standby-database/dg-14.png" width="720" height="450"></p>

<ul>
<li>&#8220;リアルタイム問い合わせ&#8221; の &#8220;無効&#8221; をクリック</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-real-time-query/dgrq-1.png" width="720" height="450"></p>

<ul>
<li>&#8220;リアルタイム問い合わせの有効化&#8221; をチェックして、&#8221;適用&#8221; をクリック</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-real-time-query/dgrq-2.png" width="720" height="450"></p>

<ul>
<li>処理中 -> 正常に適用された</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-real-time-query/dgrq-3.png" width="720" height="450"></p>

<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-real-time-query/dgrq-4.png" width="720" height="450"></p>

<ul>
<li>Data Guard の構成画面に戻ると &#8220;リアルタイム問い合わせ&#8221; が &#8220;有効&#8221; になっている</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-real-time-query/dgrq-5.png" width="720" height="450"></p>

<p>実際にスタンバイ DB に接続すると、SELECT が実行可能でプライマリの変更が REDO 適用された時点で即時反映されることが確認できる。</p>

<pre><code>SQL&gt; connect scott/tiger@PROD1 -- プライマリに接続
Connected.
SQL&gt; CREATE TABLE emp2 AS SELECT * FROM emp;

Table created.

SQL&gt; connect scott/tiger@STDBY1_DGMGRL -- スタンバイに接続
Connected.
SQL&gt; SELECT * FROM emp2 WHERE ROWNUM = 1; -- プライマリの更新が反映されている

     EMPNO ENAME                          JOB                                MGR
---------- ------------------------------ --------------------------- ----------
HIREDATE        SAL       COMM     DEPTNO
-------- ---------- ---------- ----------
      7369 SMITH                          CLERK                             7902
80-12-17        800                    20


SQL&gt; UPDATE emp2 SET sal = sal * 10 WHERE empno = 7369; -- スタンバイの更新はできない
UPDATE emp2 SET sal = sal * 10 WHERE empno = 7369
       *
ERROR at line 1:
ORA-16000: database open for read-only access
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] Data Guard スナップショット・スタンバイ・データベース]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-snapshot-standby-database/"/>
    <updated>2012-09-09T21:51:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-snapshot-standby-database</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>Data Guard の &#8220;スナップショット・スタンバイ・データベース&#8221; 機能により、スタンバイ DB を一時的に更新可能にする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
<li>EM: Oracle Enterprise Manager Grid Control 11g (11.1)</li>
</ul>


<h2>スナップショット・スタンバイ・データベースへの変換</h2>

<p>Data Guard の &#8220;スナップショット・スタンバイ・データベース&#8221; 機能により、スタンバイ DB が一時的に更新可能にできる。&#8221;スナップショット・スタンバイ・データベース&#8221; となっている間はプライマリからの REDO は適用されず、元に戻すとスタンバイ DB での更新は破棄されて、プライマリからの REDO 適用が再開される。例えば、一時的にスタンバイ DB をテスト環境として使用する場合に使える。</p>

<p>EM Grid Control を使用すると変換が楽にできる。(&#8220;変換&#8221; をクリックするだけ)</p>

<ul>
<li>プライマリ DB インスタンスの &#8220;可用性&#8221; タブ内の Data Guard の項目から &#8220;設定および管理&#8221; をクリックして、Data Guard のページを開く</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-creating-a-physical-standby-database/dg-14.png" width="720" height="450"></p>

<ul>
<li>&#8220;変換&#8221; をクリック</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-snapshot-standby-database/dgss-1.png" width="720" height="450"></p>

<ul>
<li>&#8220;はい&#8221;</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-snapshot-standby-database/dgss-2.png" width="720" height="450"></p>

<ul>
<li>処理中 -> 完了</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-snapshot-standby-database/dgss-3.png" width="720" height="450"></p>

<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-creating-a-physical-standby-database/dg-13.png" width="720" height="450"></p>

<p>なぜか上記画面のまま &#8220;概要&#8221; のページに戻らない。alert.log を確認して処理が終わっていそうだったら、EM の画面を切り替えてしまってよい。</p>

<ul>
<li>ロールが &#8220;スナップショット・スタンバイ&#8221; になる。</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-snapshot-standby-database/dgss-4.png" width="720" height="450"></p>

<p>スナップショット・スタンバイ DB に対しては DB に変更も可能。</p>

<pre><code>$ sqlplus scott/tiger@STDBY1_DGMGRL
SQL&gt; CREATE TABLE emp2 AS SELECT * FROM emp;

Table created.
</code></pre>

<p>フィジカル・スタンバイ DB に戻す場合はもう一度 EM から &#8220;変換&#8221; をクリックすればよい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] Data Guard スイッチオーバー]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-switchover/"/>
    <updated>2012-09-09T21:19:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/09/oracle-data-guard-switchover</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>Data Guard のスイッチオーバーを実行して、プライマリとスタンバイを切り替える。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
<li>EM: Oracle Enterprise Manager Grid Control 11g (11.1)</li>
</ul>


<h2>スイッチオーバーの実施</h2>

<p>EM Grid Control を使用してスイッチオーバーを行う。</p>

<ul>
<li>プライマリ DB インスタンスの &#8220;可用性&#8221; タブ内の Data Guard の項目から &#8220;設定および管理&#8221; をクリックして、Data Guard のページを開く</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-creating-a-physical-standby-database/dg-14.png" width="720" height="450"></p>

<ul>
<li>&#8220;スイッチオーバー&#8221; をクリック</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-1.png" width="720" height="450"></p>

<ul>
<li>スタンバイ・サイト に接続する OS ユーザを入力</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-2.png" width="720" height="450"></p>

<ul>
<li>プライマリ・サイト に接続する OS ユーザを入力</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-3.png" width="720" height="450"></p>

<ul>
<li>&#8220;はい&#8221;</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-4.png" width="720" height="450"></p>

<ul>
<li>処理中 -> 完了</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-5.png" width="720" height="450"></p>

<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-6.png" width="720" height="450"></p>

<p>なぜか上記画面のまま &#8220;概要&#8221; のページに戻らない。alert.log を確認して処理が終わっていそうだったら、EM の画面を切り替えてしまってよい。</p>

<ul>
<li>今度は元スタンバイでプライマリになったインスタンスの &#8220;可用性&#8221; タブ内の Data Guard の項目から &#8220;設定および管理&#8221; をクリックして、スイッチオーバーされている(プライマリ/スタンバイが切り替わっている)ことを確認</li>
</ul>


<p><img src="http://th0x4c.github.com/images/2012-09-09-oracle-data-guard-switchover/dgso-7.png" width="720" height="450"></p>
]]></content>
  </entry>
  
</feed>
