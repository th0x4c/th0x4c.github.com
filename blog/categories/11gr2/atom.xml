<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 11gR2 | th0x4c 備忘録]]></title>
  <link href="http://th0x4c.github.com/blog/categories/11gr2/atom.xml" rel="self"/>
  <link href="http://th0x4c.github.com/"/>
  <updated>2012-09-16T19:15:11+09:00</updated>
  <id>http://th0x4c.github.com/</id>
  <author>
    <name><![CDATA[Takashi Hashizume]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Oracle] 結果キャッシュ]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-result-cache/"/>
    <updated>2012-09-16T18:40:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-result-cache</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>"結果キャッシュ" 機能を使用する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
-> 7 メモリーの構成および使用方法<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/memory.htm#BGBCABED">7.6 サーバーおよびクライアントの結果キャッシュの管理</a></li>
</ul>


<h2>結果キャッシュの使用</h2>

<p>"結果キャッシュ" 機能を使用することで、問い合わせ結果を再利用してパフォーマンスを向上させることができる。</p>

<ul>
<li>初期化パラメータの設定</li>
</ul>


<p>結果キャッシュを有効にするためには初期化パラメータ <code>RESULT_CACHE_MAX_SIZE</code> を 0 より大きくする必要がある。</p>

<p>0 の場合は結果キャッシュは無効となる。(以下のように <code>DBMS_RESULT_CACHE.STATUS</code> の結果が <code>DISABLED</code> となっている。)</p>

<pre><code>SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       0
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
DISABLED
</code></pre>

<p>初期化パラメータ <code>RESULT_CACHE_MAX_SIZE</code> は以下のように動的に変更できるが、実際はインスタンスを再起動しないと有効にならなかった。</p>

<pre><code>SQL&gt; ALTER SYSTEM SET result_cache_max_size = 15M SCOPE=both;

System altered.

SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       15M
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
DISABLED
</code></pre>

<p>インスタンスを再起動すると、有効になり、<code>DBMS_RESULT_CACHE.STATUS</code> も <code>ENABLED</code> に変わる。</p>

<pre><code>SQL&gt; shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL&gt; startup
ORACLE instance started.

Total System Global Area  835104768 bytes
Fixed Size                  2232960 bytes
Variable Size             734006656 bytes
Database Buffers           92274688 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.
SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       15M
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
ENABLED
</code></pre>

<ul>
<li>結果キャッシュの使用</li>
</ul>


<p>結果キャッシュを使用するには <code>/*+ RESULT_CACHE */</code> ヒントを付与して問い合わせを実行すればよい。</p>

<pre><code>SQL&gt; SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp;
</code></pre>

<ul>
<li>結果キャッシュの確認</li>
</ul>


<p>実行計画で、<code>RESULT CACHE</code> と出ていると結果キャッシュが使われている。</p>

<pre><code>SQL&gt; set lines 200
SQL&gt; set autotrace on
SQL&gt; SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp;

  AVG(SAL)
----------
2083.21429


Execution Plan
----------------------------------------------------------
Plan hash value: 2083865914

--------------------------------------------------------------------------------------------------
| Id  | Operation           | Name                       | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |                            |     1 |     4 |     3   (0)| 00:00:01 |
|   1 |  RESULT CACHE       | 4z1ag1pqa9zqm704zf4nuj9tq4 |       |       |            |          |
|   2 |   SORT AGGREGATE    |                            |     1 |     4 |            |          |
|   3 |    TABLE ACCESS FULL| EMP                        |    14 |    56 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------

Result Cache Information (identified by operation id):
------------------------------------------------------

   1 - column-count=1; dependencies=(SCOTT.EMP); attributes=(single-row); name="SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp"


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          0  consistent gets
          0  physical reads
          0  redo size
        545  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>また、<code>V$RESULT_CACHE_OBJECTS</code> からも結果キャッシュについて確認できる。</p>

<pre><code>SQL&gt; SELECT type, status, name FROM v$result_cache_objects;

TYPE                           STATUS
------------------------------ ---------------------------
NAME
--------------------------------------------------------------------------------
Dependency                     Published
SCOTT.EMP

Result                         Published
SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] フラッシュバック・データ・アーカイブ(Oracle Total Recall)]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-flashback-data-archive-oracle-total-recall/"/>
    <updated>2012-09-16T17:16:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-flashback-data-archive-oracle-total-recall</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>フラッシュバック・データ・アーカイブ(Oracle Total Recall) を使用して、表への更新履歴を長期間保存する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>アドバンスト・アプリケーション開発者ガイド<br/>
-> 12 Oracle Flashback Technologyの使用<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56259/adfns_flashback.htm#BJFFDCEH">フラッシュバック・データ・アーカイブの使用(Oracle Total Recall)</a></li>
</ul>


<h2>フラッシュバック・データ・アーカイブの使用</h2>

<p>フラッシュバック・データ・アーカイブ(Oracle Total Recall) を使用して、表への更新履歴を長期間保存できる。例えば、コンプライアンス上変更履歴を年単位で長時間保存しておく必要がある場合などに有効。</p>

<ul>
<li>フラッシュバック・データ・アーカイブの作成</li>
</ul>


<p><code>CREATE FLASHBACK ARCHIVE</code> 文を使用してフラッシュバック・データ・アーカイブを作成する。
データを1年間保持するデフォルトのフラッシュバック・データ・アーカイブ <code>fla1</code> を <code>USERS</code> 表領域に作成。
作成するには <code>FLASHBACK ARCHIVE ADMINISTER</code> システム権限を持つユーザか、SYSDBA として接続する必要がある。</p>

<pre><code>SQL&gt; connect /as sysdba
Connected.
SQL&gt; CREATE FLASHBACK ARCHIVE DEFAULT fla1 TABLESPACE users
     RETENTION 1 YEAR;

Flashback archive created.
</code></pre>

<ul>
<li>表のフラッシュバック・アーカイブの有効化</li>
</ul>


<p><code>scott.emp</code> 表のフラッシュバック・アーカイブを有効にして、フラッシュバック・データ・アーカイブ <code>fla1</code> に履歴データを格納するようにする。
<code>scott</code> スキーマに <code>fla1</code> に対する <code>FLASHBACK ARCHIVE</code> オブジェクト権限を与えて、<code>ALTER TABLE</code> 文を発行する。</p>

<pre><code>SQL&gt; connect /as sysdba
Connected.
SQL&gt; GRANT FLASHBACK ARCHIVE ON fla1 TO scott;

Grant succeeded.

SQL&gt; connect scott/tiger
Connected.
SQL&gt; ALTER TABLE scott.emp FLASHBACK ARCHIVE fla1;

Table altered.
</code></pre>

<ul>
<li>フラッシュバック・データ・アーカイブが有効になっていることの確認</li>
</ul>


<p><code>scott</code> スキーマで <code>emp</code> 表のフラッシュバック・データ・アーカイブが有効になっていることの確認</p>

<pre><code>SQL&gt; connect scott/tiger
Connected.
SQL&gt; col table_name for a30
     col owner_name for a30
     col flashback_archive_name for a30
     col archive_table_name for a30
     col status for a10
     set lines 200
SQL&gt; SELECT * FROM USER_FLASHBACK_ARCHIVE_TABLES;

TABLE_NAME                     OWNER_NAME                     FLASHBACK_ARCHIVE_NAME         ARCHIVE_TABLE_NAME             STATUS
------------------------------ ------------------------------ ------------------------------ ------------------------------ ----------
EMP                            SCOTT                          FLA1                           SYS_FBA_HIST_75335             ENABLED
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 時間隔パーティション表]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-interval-partitioned-table/"/>
    <updated>2012-09-16T16:46:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-interval-partitioned-table</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>時間隔パーティション表を作成する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>VLDBおよびパーティショニング・ガイド<br/>
-> 4 パーティションの管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56316/part_admin001.htm#BAJHFFBE">時間隔パーティション表の作成</a></li>
</ul>


<h2>時間隔パーティション表の作成</h2>

<p>時間隔パーティション表はレンジ・パーティションの一種で、例えば月単位の時間隔パーティション表を作成すると、パーティションを明示的に作成しなくても自動で必要な月のパーティションをデータ insert 時に作成してくれる。</p>

<p><code>DATE</code> 型の <code>time_id</code> をパーティション・キーとして、2009年までは年単位でパーティション化し、2010年1月1日以降は月単位でパーティションを自動作成するような時間隔パーティション表を作成してみる。</p>

<pre><code>SQL&gt; CREATE TABLE interval_sales
         ( prod_id        NUMBER(6)
         , cust_id        NUMBER
         , time_id        DATE
         , channel_id     CHAR(1)
         , promo_id       NUMBER(6)
         , quantity_sold  NUMBER(3)
         , amount_sold    NUMBER(10,2)
         ) 
       PARTITION BY RANGE (time_id) 
       INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
         ( PARTITION p0 VALUES LESS THAN (TO_DATE('1-1-2008', 'DD-MM-YYYY')),
           PARTITION p1 VALUES LESS THAN (TO_DATE('1-1-2009', 'DD-MM-YYYY')),
           PARTITION p2 VALUES LESS THAN (TO_DATE('1-1-2010', 'DD-MM-YYYY')) );

Table created.
</code></pre>

<p>ちなみに追加されるパーティションを日単位にする場合は、<code>NUMTODSINTERVAL(1, 'DAY')</code> 関数を利用する。</p>

<p>パーティション情報の確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col partitioning_type for a20
     set lines 200
SQL&gt; SELECT table_name, partitioning_type FROM user_part_tables;

TABLE_NAME                     PARTITIONING_TYPE   
------------------------------ --------------------
INTERVAL_SALES                 RANGE

SQL&gt; col partition_name for a30
SQL&gt; SELECT table_name, partition_name, high_value FROM user_tab_partitions ORDER BY table_name, partition_position;

TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE
------------------------------ ------------------------------ --------------------------------------------------------------------------------
INTERVAL_SALES                 P0                             TO_DATE(' 2008-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P1                             TO_DATE(' 2009-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P2                             TO_DATE(' 2010-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
</code></pre>

<p>最初はパーティションは作られていないが、上記の範囲を超える行を insert するとパーティションが自動で作成される。</p>

<pre><code>SQL&gt; INSERT INTO interval_sales(prod_id, time_id) VALUES(1, TO_DATE('2012-09-16', 'YYYY-MM-DD'));

1 row created.

SQL&gt; COMMIT;

Commit complete.

SQL&gt; SELECT table_name, partition_name, high_value FROM user_tab_partitions ORDER BY table_name, partition_position;

TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE
------------------------------ ------------------------------ --------------------------------------------------------------------------------
INTERVAL_SALES                 P0                             TO_DATE(' 2008-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P1                             TO_DATE(' 2009-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 P2                             TO_DATE(' 2010-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
INTERVAL_SALES                 SYS_P41                        TO_DATE(' 2012-10-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
</code></pre>

<p><code>SYS_P41</code> というパーティションが自動で作成された。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 参照パーティション表]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-reference-partitioned-table/"/>
    <updated>2012-09-16T16:13:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-reference-partitioned-table</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>参照パーティション表を作成する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>VLDBおよびパーティショニング・ガイド<br/>
-> 4 パーティションの管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56316/part_admin001.htm#BAJDDEEC">参照パーティション表の作成</a></li>
</ul>


<h2>参照パーティション表の作成</h2>

<p>参照パーティション表は、例えば次のようなケースで役立つ。注文を管理する orders 表に注文日が格納される order_date 列がある。また、注文に含まれる品目を管理する order_items 表があり、orders 表を order_id 列で外部参照しているとする。orders 表が order_date 列をキー値としてパーティション化されている場合、order_items 表も同じように注文日によりパーティション化したかったら、従来ならば order_date 列を order_itmes 表にも加える必要があった。参照パーティション表を使えば、order_items 列に余計な order_date 列を加えることなく、外部参照している orders と同じ単位でパーティション化することができる。</p>

<p>実際に上記シナリオで参照パーティション表を作成してみる。</p>

<pre><code>SQL&gt; CREATE TABLE orders
         ( order_id           NUMBER(12),
           order_date         DATE,
           order_mode         VARCHAR2(8),
           customer_id        NUMBER(6),
           order_status       NUMBER(2),
           order_total        NUMBER(8,2),
           sales_rep_id       NUMBER(6),
           promotion_id       NUMBER(6),
           CONSTRAINT orders_pk PRIMARY KEY(order_id)
         )
       PARTITION BY RANGE(order_date)
         ( PARTITION Q1_2005 VALUES LESS THAN (TO_DATE('01-APR-2005','DD-MON-YYYY')),
           PARTITION Q2_2005 VALUES LESS THAN (TO_DATE('01-JUL-2005','DD-MON-YYYY')),
           PARTITION Q3_2005 VALUES LESS THAN (TO_DATE('01-OCT-2005','DD-MON-YYYY')),
           PARTITION Q4_2005 VALUES LESS THAN (TO_DATE('01-JAN-2006','DD-MON-YYYY'))
         );

Table created.

SQL&gt; CREATE TABLE order_items
         ( order_id           NUMBER(12) NOT NULL,
           line_item_id       NUMBER(3)  NOT NULL,
           product_id         NUMBER(6)  NOT NULL,
           unit_price         NUMBER(8,2),
           quantity           NUMBER(8),
           CONSTRAINT order_items_fk
           FOREIGN KEY(order_id) REFERENCES orders(order_id)
         )
         PARTITION BY REFERENCE(order_items_fk);

Table created. 
</code></pre>

<p>パーティション情報の確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col partitioning_type for a20
     col ref_ptn_constraint_name for a30
     set lines 200
SQL&gt; SELECT table_name, partitioning_type, ref_ptn_constraint_name FROM user_part_tables;

TABLE_NAME                     PARTITIONING_TYPE    REF_PTN_CONSTRAINT_NAME
------------------------------ -------------------- ------------------------------
ORDERS                         RANGE
ORDER_ITEMS                    REFERENCE            ORDER_ITEMS_FK

SQL&gt; col partition_name for a30
SQL&gt; SELECT table_name, partition_name, high_value FROM user_tab_partitions ORDER BY table_name, partition_position;

TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE
------------------------------ ------------------------------ --------------------------------------------------------------------------------
ORDERS                         Q1_2005                        TO_DATE(' 2005-04-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDERS                         Q2_2005                        TO_DATE(' 2005-07-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDERS                         Q3_2005                        TO_DATE(' 2005-10-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDERS                         Q4_2005                        TO_DATE(' 2006-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
ORDER_ITEMS                    Q1_2005
ORDER_ITEMS                    Q2_2005
ORDER_ITEMS                    Q3_2005
ORDER_ITEMS                    Q4_2005
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] BasicFiles LOB から SecureFiles LOB への移行]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-securefiles-lob/"/>
    <updated>2012-09-16T14:15:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-securefiles-lob</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>従来型の LOB (BasicFiles LOB) から、Oracle Database 11g からの新しい LOB アーキテクチャである SecureFiles を使用した LOB へ移行する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li><p>SecureFilesおよびラージ・オブジェクト開発者ガイド<br/>
-> 4 Oracle SecureFiles LOBの使用<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#BABDIEGE">BasicFiles LOBからSecureFiles LOBへの列の移行</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#BABJFEBB">SecureFiles LOBの初期化パラメータdb_securefile</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#CIHGHEFA">SecureFiles LOBを含んだCREATE TABLEの使用</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#CIHJJBIJ">SecureFiles LOBを含んだALTER TABLEの使用</a></p></li>
<li><p>管理者ガイド<br/>
-> 20 表の管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56301/tables007.htm#i1006754">表のオンライン再定義</a></p></li>
</ul>


<h2>BasicFiles LOB から SecureFiles LOB への移行</h2>

<p>Oracle Database 11g からの新しい LOB アーキテクチャである SecureFiles を使用した LOB を使用すると、以下のようなことが可能になる。</p>

<ul>
<li>圧縮(LOB データの圧縮)</li>
<li>重複除外(列内で重複する LOB データのコピーを1つのみ格納)</li>
<li>暗号化(透過的データ暗号化により LOB データを暗号化)</li>
</ul>


<p>従来型の LOB は、BasicFiles と呼ばれる。BasicFiles を使用した既存の LOB 列を SecureFiles に移行する。<code>ALTER TABLE</code> での BasicFiles から SecureFiles への変更はできないため、変更するためには表の再作成を行うか、オンライン再定義を行う必要がある。今回は、マニュアルに例があるように、オンライン再定義により行う。</p>

<ul>
<li>検証用に BasicFiles LOB 列を持つ表、データを準備</li>
</ul>


<p>BasicFiles LOB 列を持つ <code>cust</code> 表を作成してデータを insert。今回この表を SecureFiles LOB に移行してみる。</p>

<pre><code>SQL&gt; connect scott/tiger
SQL&gt; CREATE TABLE cust
     (
       c_id  NUMBER PRIMARY KEY,
       c_zip NUMBER,
       c_name VARCHAR(30) DEFAULT NULL,
       c_lob CLOB
     );

Table created.

SQL&gt; INSERT INTO cust VALUES(1, 94065, 'hhh', 'ttt');

1 row created.

SQL&gt; COMMIT;

Commit complete.
</code></pre>

<ul>
<li>オンライン再定義に必要な権限の付与</li>
</ul>


<p>オンライン再定義に必要な権限を与える</p>

<pre><code>SQL&gt; connect /as sysdba
SQL&gt; -- Grant privileges required for online redefinition.
SQL&gt; GRANT EXECUTE ON DBMS_REDEFINITION TO scott;
SQL&gt; GRANT ALTER ANY TABLE TO scott;
SQL&gt; GRANT DROP ANY TABLE TO scott;
SQL&gt; GRANT LOCK ANY TABLE TO scott;
SQL&gt; GRANT CREATE ANY TABLE TO scott;
SQL&gt; GRANT SELECT ANY TABLE TO scott;
SQL&gt; -- Privileges required to perform cloning of dependent objects.
SQL&gt; GRANT CREATE ANY TRIGGER TO scott;
SQL&gt; GRANT CREATE ANY INDEX TO scott;
</code></pre>

<ul>
<li>初期化パラメータ <code>db_securefile</code> パラメータの変更</li>
</ul>


<p>SecureFiles LOB の初期化パラメータ <code>db_securefile</code> パラメータを変更する。
SecureFiles LOB を使用するためには <code>PERMITTED</code> (デフォルト) または <code>ALWAYS</code> である必要がある。</p>

<p>例えば、<code>NEVER</code> に設定されている場合に SecureFiles LOB の列を作成しようとすると、<code>ORA-43856</code> が発生する。</p>

<pre><code>SQL&gt; CREATE TABLE test_lob (c_lob CLOB) LOB(c_lob) STORE AS SECUREFILE (compress high);
CREATE TABLE test_lob (c_lob CLOB) LOB(c_lob) STORE AS SECUREFILE (compress high)
*
ERROR at line 1:
ORA-43856: Unsupported LOB type for SECUREFILE LOB operation
</code></pre>

<p><code>db_securefile</code> を <code>ALTER SYSTEM</code> で変更する。</p>

<pre><code>SQL&gt; conn /as sysdba
Connected.
SQL&gt; ALTER SYSTEM SET db_securefile = PERMITTED SCOPE=both;

System altered.
</code></pre>

<ul>
<li>仮表を作成</li>
</ul>


<p>オンライン再定義のための仮表を SecureFiles LOB 列を持つようにして作成。元表からコピーされるので主キーなどの制約の指定は不要。</p>

<pre><code>SQL&gt; connect scott/tiger
Connected.
SQL&gt; CREATE TABLE cust_int
     (
       c_id  NUMBER,
       c_zip NUMBER,
       c_name VARCHAR(30) DEFAULT NULL,
       c_lob CLOB
     )
     LOB(c_lob) STORE AS SECUREFILE;

Table created.
</code></pre>

<ul>
<li>表のオンライン再定義</li>
</ul>


<p>表のオンライン再定義を実行する。</p>

<pre><code>SQL&gt; DECLARE
       col_mapping VARCHAR2(1000);
     BEGIN
       -- map all the columns in the interim table to the original table
       col_mapping :=
         'c_id c_id , '||
         'c_zip c_zip , '||
         'c_name c_name, '||
         'c_lob c_lob';
       DBMS_REDEFINITION.START_REDEF_TABLE('scott', 'cust', 'cust_int', col_mapping);
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; set serveroutput on
SQL&gt; DECLARE
       error_count pls_integer := 0;
     BEGIN
       DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS('scott', 'cust', 'cust_int',
         1, TRUE,TRUE,TRUE,FALSE, error_count);
       DBMS_OUTPUT.PUT_LINE('errors := ' || TO_CHAR(error_count));
     END;
     /
errors := 0

PL/SQL procedure successfully completed.

SQL&gt; EXEC DBMS_REDEFINITION.FINISH_REDEF_TABLE('scott', 'cust', 'cust_int');

PL/SQL procedure successfully completed.

SQL&gt; DROP TABLE cust_int;

Table dropped.
</code></pre>

<ul>
<li>SecureFiles LOB に移行されたことを確認</li>
</ul>


<p><code>USER_LOBS.SECUREFILE</code> 列が <code>YES</code> であれば SecureFiles になっている。</p>

<pre><code>SQL&gt; col table_name for a30
SQL&gt; col column_name for a30
SQL&gt; SELECT table_name, column_name, securefile FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    SECUREFIL
------------------------------ ------------------------------ ---------
CUST                           C_LOB                          YES
</code></pre>

<h2>SecureFiles LOB の変更</h2>

<p><code>ALTER TABLE</code> 文により既存の SecureFiles LOB 列を変更して、圧縮や重複除外の設定を行う。</p>

<ul>
<li>現在の設定の確認</li>
</ul>


<p><code>USER_LOBS</code> にて確認できる。</p>

<pre><code>SQL&gt; col table_name for a30
     col column_name for a30
     col encrypt for a10
     col compression for a15
     col deduplication for a15
     set lines 200
SQL&gt; SELECT table_name, column_name, encrypt, compression, deduplication FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    ENCRYPT    COMPRESSION     DEDUPLICATION
------------------------------ ------------------------------ ---------- --------------- ---------------
CUST                           C_LOB                          NO         NO              NO
</code></pre>

<ul>
<li>設定の変更</li>
</ul>


<p><code>ALTER TABLE</code> により圧縮、重複除外の設定を行う。</p>

<pre><code>SQL&gt; ALTER TABLE cust MODIFY LOB(c_lob) (COMPRESS HIGH);

Table altered.

SQL&gt; ALTER TABLE cust MODIFY LOB(c_lob) (DEDUPLICATE);

Table altered.
</code></pre>

<ul>
<li>設定変更の確認</li>
</ul>


<p><code>USER_LOBS</code> にて確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col column_name for a30
     col encrypt for a10
     col compression for a15
     col deduplication for a15
     set lines 200
SQL&gt; SELECT table_name, column_name, encrypt, compression, deduplication FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    ENCRYPT    COMPRESSION     DEDUPLICATION
------------------------------ ------------------------------ ---------- --------------- ---------------
CUST                           C_LOB                          NO         HIGH            LOB
</code></pre>
]]></content>
  </entry>
  
</feed>
