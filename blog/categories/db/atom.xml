<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DB | th0x4c 備忘録]]></title>
  <link href="http://th0x4c.github.com/blog/categories/db/atom.xml" rel="self"/>
  <link href="http://th0x4c.github.com/"/>
  <updated>2013-11-14T20:57:20+09:00</updated>
  <id>http://th0x4c.github.com/</id>
  <author>
    <name><![CDATA[Takashi Hashizume]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Oracle] v$session, v$active_session_history の階層問合せによる待機のブロッキング・セッションの特定]]></title>
    <link href="http://th0x4c.github.com/blog/2013/11/05/oracle-using-hierarchical-queries-to-identify-the-blocking-session/"/>
    <updated>2013-11-05T21:51:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2013/11/05/oracle-using-hierarchical-queries-to-identify-the-blocking-session</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>v$session, v$active_session_history の blocking_session 列で待機をブロックしているセッションが分かるが、階層問合せによって待機をツリー状に表示して辿ることで最終的にブロックしているセッションを特定する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>前提知識</h2>

<h3>v$session.blocking_session 列、v$active_session_history.blocking_session 列</h3>

<p>v$session, v$active_session_history の blocking_session 列でそのセッションをブロックしているセッションの SID が分かる。
(例えばそのセッションが要求しているロックを保持しているセッションの SID)</p>

<h3>階層問合せ</h3>

<p>階層問合せ(もしくは 再帰クエリ)によって、親子関係があるような階層構造、ツリー構造を持つデータの問合せができる。
Oracle Database では独自の <code>CONNECT BY</code> 句を使った問合せを行う。
(11gR2 からは業界標準 SQL99 の再帰 <code>with</code> 句での問合せも可能)</p>

<p>例えば EMP 表には各従業員の EMPNO 列と、その上位マネージャの EMPNO である MGR 列があるが、以下の階層問合せでマネージャと部下の親子関係を表示できる。
(以下は Wikipedia <a href="http://ja.wikipedia.org/wiki/%E5%86%8D%E5%B8%B0%E3%82%AF%E3%82%A8%E3%83%AA">再帰クエリ</a> から抜粋)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="k">LEVEL</span><span class="p">,</span> <span class="n">LPAD</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">LEVEL</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="n">ename</span> <span class="n">employee</span><span class="p">,</span> <span class="n">empno</span><span class="p">,</span> <span class="n">mgr</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">emp</span>
</span><span class='line'><span class="k">START</span> <span class="k">WITH</span> <span class="n">mgr</span> <span class="k">IS</span> <span class="k">NULL</span>
</span><span class='line'><span class="k">CONNECT</span> <span class="k">BY</span> <span class="k">PRIOR</span> <span class="n">empno</span> <span class="o">=</span> <span class="n">mgr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<pre><code> LEVEL EMPLOYEE         EMPNO    MGR
------ --------------- ------ ------
     1 KING              7839
     2   JONES           7566   7839
     3     SCOTT         7788   7566
     4       ADAMS       7876   7788
     3     FORD          7902   7566
     4       SMITH       7369   7902
     2   BLAKE           7698   7839
     3     ALLEN         7499   7698
     3     WARD          7521   7698
     3     MARTIN        7654   7698
     3     TURNER        7844   7698
     3     JAMES         7900   7698
     2   CLARK           7782   7839
     3     MILLER        7934   7782
</code></pre>

<h2>v$session の階層問合せによる待機のブロッキング・セッションの特定</h2>

<p>実際に複数セッションで待機状態を作って試す。</p>

<ul>
<li><p>セッション1:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7369;</code></li>
</ul>
</li>
<li><p>セッション2:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7499;</code></li>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7369;</code> (セッション1を待機)</li>
</ul>
</li>
<li><p>セッション3:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7521;</code></li>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7499;</code> (セッション2を待機)</li>
</ul>
</li>
<li><p>セッション4:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7566;</code></li>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7369;</code> (セッション1を待機)</li>
</ul>
</li>
<li><p>セッション5:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7521;</code> (セッション3を待機)</li>
</ul>
</li>
<li><p>セッション6:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7499;</code> (セッション2を待機)</li>
</ul>
</li>
<li><p>セッション7:</p>

<ul>
<li><code>UPDATE emp SET sal = sal WHERE empno = 7566;</code> (セッション4を待機)</li>
</ul>
</li>
</ul>


<p>階層問合せを行い、待機状態を確認する。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">set</span> <span class="n">pages</span> <span class="mi">1000</span>
</span><span class='line'><span class="k">set</span> <span class="n">lines</span> <span class="mi">200</span>
</span><span class='line'><span class="n">col</span> <span class="k">level</span>     <span class="k">for</span> <span class="mi">9999</span>
</span><span class='line'><span class="n">col</span> <span class="k">hierarchy</span> <span class="k">for</span> <span class="n">a20</span>
</span><span class='line'><span class="n">col</span> <span class="n">path</span>      <span class="k">for</span> <span class="n">a20</span>
</span><span class='line'><span class="n">col</span> <span class="n">sid</span>       <span class="k">for</span> <span class="mi">9999</span>
</span><span class='line'><span class="n">col</span> <span class="n">event</span>     <span class="k">for</span> <span class="n">a32</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">SELECT</span>
</span><span class='line'>  <span class="k">LEVEL</span><span class="p">,</span>
</span><span class='line'>  <span class="n">LPAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">LEVEL</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="n">sid</span> <span class="k">hierarchy</span><span class="p">,</span>
</span><span class='line'>  <span class="n">SYS_CONNECT_BY_PATH</span><span class="p">(</span><span class="n">sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;)</span> <span class="n">path</span><span class="p">,</span>
</span><span class='line'>  <span class="n">sid</span><span class="p">,</span>
</span><span class='line'>  <span class="n">blocking_session</span><span class="p">,</span>
</span><span class='line'>  <span class="n">event</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">v</span><span class="err">$</span><span class="k">session</span>
</span><span class='line'><span class="k">START</span> <span class="k">WITH</span> <span class="n">blocking_session</span> <span class="k">IS</span> <span class="k">NULL</span>
</span><span class='line'><span class="k">CONNECT</span> <span class="k">BY</span> <span class="k">PRIOR</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">blocking_session</span>
</span><span class='line'><span class="k">ORDER</span> <span class="n">SIBLINGS</span> <span class="k">BY</span> <span class="n">sid</span>
</span><span class='line'><span class="o">/</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<pre><code>SQL&gt; SELECT
       LEVEL,
       LPAD(' ', 2 * (LEVEL - 1)) || sid hierarchy,
       SYS_CONNECT_BY_PATH(sid, '&lt;-') path,
       sid,
       blocking_session,
       event
     FROM v$session
     START WITH blocking_session IS NULL
     CONNECT BY PRIOR sid = blocking_session
     ORDER SIBLINGS BY sid
     /

LEVEL HIERARCHY            PATH                   SID BLOCKING_SESSION EVENT
----- -------------------- -------------------- ----- ---------------- --------------------------------
    1 1                    &lt;-1                      1                  pmon timer
    1 2                    &lt;-2                      2                  VKTM Logical Idle Wait
    1 3                    &lt;-3                      3                  DIAG idle wait

...(*snip*)

    1 141                  &lt;-141                  141                  SQL*Net message from client
    2   10                 &lt;-141&lt;-10               10              141 enq: TX - row lock contention
    3     20               &lt;-141&lt;-10&lt;-20           20               10 enq: TX - row lock contention
    3     136              &lt;-141&lt;-10&lt;-136         136               10 enq: TX - row lock contention
    4       143            &lt;-141&lt;-10&lt;-136&lt;-143    143              136 enq: TX - row lock contention
    2   19                 &lt;-141&lt;-19               19              141 enq: TX - row lock contention
    3     142              &lt;-141&lt;-19&lt;-142         142               19 enq: TX - row lock contention
</code></pre>

<ul>
<li>セッション1(SID=141) を セッション2(SID=10) と セッション4(SID=19) が待機して、</li>
<li>セッション2(SID=10) を セッション3(SID=136) と セッション6(SID=20) が待機して、</li>
<li>セッション3(SID=136) を セッション5(SID=143) が待機して、</li>
<li>セッション4(SID=19) を セッション7(SID=142) が待機している</li>
</ul>


<p>つまり、セッション1(SID=141)が最終的にブロックしている起源(ルート)であることがわかる。</p>

<p>なお、<code>LEVEL</code> 疑似列により階層のレベルが分かる。また、<code>SYS_CONNECT_BY_PATH</code> により階層のパスを表すことができる。</p>

<h2>v$active_session_history の階層問合せによる待機のブロッキング・セッションの特定</h2>

<p>v$active_session_history では、アイドル以外の待機状態もしくは CPU 使用中のセッションしか現れない。
上述の例のように最終的に待機させていたセッション(セッション1:SID=141)がアイドル状態だと、ルートのセッションが現れないので単純には階層表示できない。
従って、blocking_session がすべて現れるように工夫する。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">set</span> <span class="n">pages</span> <span class="mi">1000</span>
</span><span class='line'><span class="k">set</span> <span class="n">lines</span> <span class="mi">200</span>
</span><span class='line'><span class="n">col</span> <span class="k">level</span>         <span class="k">for</span> <span class="mi">9999</span>
</span><span class='line'><span class="n">col</span> <span class="k">hierarchy</span>     <span class="k">for</span> <span class="n">a20</span>
</span><span class='line'><span class="n">col</span> <span class="n">path</span>          <span class="k">for</span> <span class="n">a20</span>
</span><span class='line'><span class="n">col</span> <span class="n">session_id</span>    <span class="k">for</span> <span class="mi">9999</span>
</span><span class='line'><span class="n">col</span> <span class="n">session_state</span> <span class="k">for</span> <span class="n">a13</span>
</span><span class='line'><span class="n">col</span> <span class="n">event</span>         <span class="k">for</span> <span class="n">a32</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">SELECT</span> <span class="k">MAX</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">v</span><span class="err">$</span><span class="n">active_session_history</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">sample_id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">sample_id</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">WITH</span> <span class="n">x</span> <span class="k">AS</span>
</span><span class='line'><span class="p">(</span>
</span><span class='line'>  <span class="k">SELECT</span> <span class="n">session_id</span><span class="p">,</span> <span class="n">blocking_session</span><span class="p">,</span> <span class="n">session_state</span><span class="p">,</span> <span class="n">event</span>
</span><span class='line'>  <span class="k">FROM</span> <span class="n">v</span><span class="err">$</span><span class="n">active_session_history</span>
</span><span class='line'>  <span class="k">WHERE</span> <span class="n">sample_id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">sample_id</span>
</span><span class='line'>  <span class="k">UNION</span> <span class="k">ALL</span>
</span><span class='line'>  <span class="k">SELECT</span> <span class="n">blocking_session</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">IDLE</span><span class="o">?&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'>  <span class="k">FROM</span> <span class="n">v</span><span class="err">$</span><span class="n">active_session_history</span>
</span><span class='line'>  <span class="k">WHERE</span> <span class="n">sample_id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">sample_id</span>
</span><span class='line'>  <span class="k">AND</span> <span class="n">blocking_session</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">session_id</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>                           <span class="k">FROM</span> <span class="n">v</span><span class="err">$</span><span class="n">active_session_history</span>
</span><span class='line'>                           <span class="k">WHERE</span> <span class="n">sample_id</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">sample_id</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">blocking_session</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="k">SELECT</span>
</span><span class='line'>  <span class="k">LEVEL</span><span class="p">,</span>
</span><span class='line'>  <span class="n">LPAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span> <span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="k">LEVEL</span> <span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="n">session_id</span> <span class="k">hierarchy</span><span class="p">,</span>
</span><span class='line'>  <span class="n">SYS_CONNECT_BY_PATH</span><span class="p">(</span><span class="n">session_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;)</span> <span class="n">path</span><span class="p">,</span>
</span><span class='line'>  <span class="n">session_id</span><span class="p">,</span>
</span><span class='line'>  <span class="n">blocking_session</span><span class="p">,</span>
</span><span class='line'>  <span class="n">session_state</span><span class="p">,</span>
</span><span class='line'>  <span class="n">event</span>
</span><span class='line'><span class="k">FROM</span> <span class="n">x</span>
</span><span class='line'><span class="k">START</span> <span class="k">WITH</span> <span class="n">blocking_session</span> <span class="k">IS</span> <span class="k">NULL</span>
</span><span class='line'><span class="k">CONNECT</span> <span class="k">BY</span> <span class="k">PRIOR</span> <span class="n">session_id</span> <span class="o">=</span> <span class="n">blocking_session</span>
</span><span class='line'><span class="k">ORDER</span> <span class="n">SIBLINGS</span> <span class="k">BY</span> <span class="n">session_id</span>
</span><span class='line'><span class="o">/&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">undefine</span> <span class="n">sample_id</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<pre><code>SQL&gt; SELECT MAX(sample_id) FROM v$active_session_history;

MAX(SAMPLE_ID)
--------------
        244679

SQL&gt; define sample_id = &amp;sample_id
Enter value for sample_id: 244679

SQL&gt; WITH x AS
     (
       SELECT session_id, blocking_session, session_state, event
       FROM v$active_session_history
       WHERE sample_id = &amp;sample_id
       UNION ALL
       SELECT blocking_session, null, null, 'IDLE?'
       FROM v$active_session_history
       WHERE sample_id = &amp;sample_id
       AND blocking_session NOT IN (SELECT session_id
                                    FROM v$active_session_history
                                    WHERE sample_id = &amp;sample_id)
       GROUP BY blocking_session
     )
     SELECT
       LEVEL,
       LPAD(' ', 2 * (LEVEL - 1)) || session_id hierarchy,
       SYS_CONNECT_BY_PATH(session_id, '&lt;-') path,
       session_id,
       blocking_session,
       session_state,
       event
     FROM x
     START WITH blocking_session IS NULL
     CONNECT BY PRIOR session_id = blocking_session
     ORDER SIBLINGS BY session_id
     /

LEVEL HIERARCHY            PATH                 SESSION_ID BLOCKING_SESSION SESSION_STATE EVENT
----- -------------------- -------------------- ---------- ---------------- ------------- --------------------------------
    1 141                  &lt;-141                       141                                IDLE?
    2   10                 &lt;-141&lt;-10                    10              141 WAITING       enq: TX - row lock contention
    3     20               &lt;-141&lt;-10&lt;-20                20               10 WAITING       enq: TX - row lock contention
    3     136              &lt;-141&lt;-10&lt;-136              136               10 WAITING       enq: TX - row lock contention
    4       143            &lt;-141&lt;-10&lt;-136&lt;-143         143              136 WAITING       enq: TX - row lock contention
    2   19                 &lt;-141&lt;-19                    19              141 WAITING       enq: TX - row lock contention
    3     142              &lt;-141&lt;-19&lt;-142              142               19 WAITING       enq: TX - row lock contention
</code></pre>

<p>アイドル状態のために現れないセッションを <code>UNION ALL</code> で仮想的に v$active_session_history に追加したインラインビュー x を使用した。
(もっといいやり方があるかもしれない。)</p>

<h2>参考</h2>

<ul>
<li>Wikipedia <a href="http://ja.wikipedia.org/wiki/%E5%86%8D%E5%B8%B0%E3%82%AF%E3%82%A8%E3%83%AA">再帰クエリ</a></li>
<li>Oracle Database SQL言語リファレンス 11gリリース2 (11.2) <a href="http://download.oracle.com/docs/cd/E16338_01/server.112/b56299/queries003.htm#i2053935">階層問合わせ</a></li>
<li>図でイメージするOracle DatabaseのSQL全集 <a href="http://www.oracle.com/technetwork/jp/articles/otnj-sql-image6-1352143-ja.html">第6回 階層問い合わせ</a>, <a href="http://www.oracle.com/technetwork/jp/articles/otnj-sql-image7-1525406-ja.html">第7回 再帰with句</a></li>
<li>Let&rsquo;s postgres <a href="http://lets.postgresql.jp/documents/technical/with_recursive">再帰SQL</a></li>
<li>@IT <a href="http://www.atmarkit.co.jp/fnetwork/tokusyuu/01sql99/sql99_1b.html">新しい業界標準「SQL99」詳細解説</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] SQL 計画管理]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-sql-plan-management/"/>
    <updated>2012-09-16T23:28:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-sql-plan-management</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>SQL 計画管理により、実行計画を固定化する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
&ndash;> 15 SQL計画の管理の使用方法<br/>
&ndash;> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/optplanmgmt.htm#BABEGJGB">15.2 SQL計画ベースラインの管理</a></li>
</ul>


<h2>SQL 計画管理</h2>

<p>SQL 計画管理により、実行計画を固定化することができる。具体的には次のステップで行う。</p>

<ol>
<li>SQL 計画の自動取得(<code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=TRUE</code>)</li>
<li>実行計画を管理する SQL を 2 回以上実行</li>
<li>取得した SQL 計画の使用(<code>OPTIMIZER_USE_SQL_PLAN_BASELINES=TRUE</code>)</li>
</ol>


<p>実際に実行してみる。</p>

<ul>
<li>SQL 計画の自動取得(<code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=TRUE</code>)</li>
</ul>


<p><code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES</code> 初期化パラメータ(デフォルト <code>FALSE</code>)を <code>TRUE</code> に設定することで SQL 計画の自動取得が有効になる。</p>

<pre><code>SQL&gt; ALTER SESSION SET OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=TRUE;

Session altered.
</code></pre>

<ul>
<li>SQL を 2 回以上実行</li>
</ul>


<p>SQL を 2 回以上実行して、SQL 計画ベースラインに保存する。</p>

<pre><code>SQL&gt; SELECT * FROM scott.emp WHERE empno = 7900;

     EMPNO ENAME                          JOB                                MGR HIREDATE        SAL       COMM     DEPTNO
---------- ------------------------------ --------------------------- ---------- -------- ---------- ---------- ----------
      7900 JAMES                          CLERK                             7698 81-12-03        960                    30

SQL&gt; SELECT * FROM scott.emp WHERE empno = 7900;

     EMPNO ENAME                          JOB                                MGR HIREDATE        SAL       COMM     DEPTNO
---------- ------------------------------ --------------------------- ---------- -------- ---------- ---------- ----------
      7900 JAMES                          CLERK                             7698 81-12-03        960                    30
</code></pre>

<ul>
<li>SQL 計画の自動取得を無効化(<code>OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=FALSE</code>)</li>
</ul>


<p>SQL 計画の自動取得を無効化する。</p>

<pre><code>SQL&gt; ALTER SESSION SET OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES=FALSE;

Session altered.
</code></pre>

<ul>
<li>SQL が SQL 計画ベースラインに保存されたことを確認</li>
</ul>


<p><code>DBA_SQL_PLAN_BASELINES</code> を確認する。</p>

<pre><code>SQL&gt; col sql_text for a60
     col sql_handle for a30
     col plan_name for a30
     set lines 200
SQL&gt; SELECT SQL_TEXT, SQL_HANDLE, PLAN_NAME, ENABLED, ACCEPTED, FIXED
     FROM   DBA_SQL_PLAN_BASELINES;

SQL_TEXT                                                     SQL_HANDLE                     PLAN_NAME                      ENABLED   ACCEPTED  FIXED
------------------------------------------------------------ ------------------------------ ------------------------------ --------- --------- ---------
SELECT * FROM scott.emp WHERE empno = 7900                   SQL_84ec680ef31d6de4           SQL_PLAN_89v381vtjuvg4695cc014 YES       YES       NO
</code></pre>

<p>実行計画を確認する。</p>

<pre><code>SQL&gt; SELECT * FROM TABLE(
       DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(
         sql_handle=&gt;'SQL_84ec680ef31d6de4',
         format=&gt;'basic'));

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
SQL handle: SQL_84ec680ef31d6de4
SQL text: SELECT * FROM scott.emp WHERE empno = 7900
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Plan name: SQL_PLAN_89v381vtjuvg4695cc014         Plan id: 1767686164
Enabled: YES     Fixed: NO      Accepted: YES     Origin: AUTO-CAPTURE
--------------------------------------------------------------------------------


PLAN_TABLE_OUTPUT
----------------------------------------------
Plan hash value: 2949544139

----------------------------------------------
| Id  | Operation                   | Name   |
----------------------------------------------
|   0 | SELECT STATEMENT            |        |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |
|   2 |   INDEX UNIQUE SCAN         | PK_EMP |
----------------------------------------------

20 rows selected.
</code></pre>

<ul>
<li>取得した SQL 計画の使用(<code>OPTIMIZER_USE_SQL_PLAN_BASELINES=TRUE</code>)</li>
</ul>


<p><code>OPTIMIZER_USE_SQL_PLAN_BASELINES</code> 初期化パラメータ(デフォルト <code>TRUE</code>)を <code>TRUE</code> に設定することで取得した SQL 計画を使用する。</p>

<pre><code>SQL&gt; ALTER SESSION SET OPTIMIZER_USE_SQL_PLAN_BASELINES=TRUE;

Session altered.
</code></pre>

<p>あとは普通に SQL を実行するだけで取得した SQL 計画が使用される。</p>

<pre><code>SQL&gt; set autotrace on
SQL&gt; SELECT * FROM scott.emp WHERE empno = 7900;

     EMPNO ENAME                          JOB                                MGR HIREDATE        SAL       COMM     DEPTNO
---------- ------------------------------ --------------------------- ---------- -------- ---------- ---------- ----------
      7900 JAMES                          CLERK                             7698 81-12-03        960                    30


Execution Plan
----------------------------------------------------------
Plan hash value: 2949544139

--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    39 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    39 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("EMPNO"=7900)

Note 
-----
   - SQL plan baseline "SQL_PLAN_89v381vtjuvg4695cc014" used for this statement


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          2  consistent gets
          0  physical reads
          0  redo size
        889  bytes sent via SQL*Net to client
        512  bytes received via SQL*Net from client
          1  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>Note の <code>SQL plan baseline "SQL_PLAN_89v381vtjuvg4695cc014" used for this statement</code> という出力から取得した SQL 計画が使用されていることが分かる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] カーソルを無効にしない統計情報の取得]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-does-not-invalidate-the-dependent-cursors-when-gathering-statistics/"/>
    <updated>2012-09-16T21:34:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-does-not-invalidate-the-dependent-cursors-when-gathering-statistics</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>カーソルを無効化せずに統計情報を取得する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>PL/SQLパッケージ・プロシージャおよびタイプ・リファレンス<br/>
&ndash;> 141 DBMS_STATS<br/>
&ndash;> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56262/d_stats.htm#i1036461">GATHER_TABLE_STATSプロシージャ</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56262/d_stats.htm#BEIBJJHC">SET_TABLE_PREFSプロシージャ</a></li>
</ul>


<h2>カーソルを無効にしない統計情報の取得</h2>

<p>カーソルを無効化せずに統計情報を取得する。
方法としては、以下の2つがある。</p>

<ol>
<li><code>DBMS_STATS.GATHER_TABLE_STATS</code> プロシージャ実行時に指定する方法</li>
<li><code>SET_*_PREFS</code> プロシージャによりデフォルト値を変更する方法</li>
</ol>


<h2><code>DBMS_STATS.GATHER_TABLE_STATS</code> プロシージャ実行時に指定する方法</h2>

<p><code>DBMS_STATS.GATHER_TABLE_STATS</code> 実行時に指定する場合は、<code>no_invalidate</code> パラメータを <code>TRUE</code> にする。</p>

<pre><code>SQL&gt; EXEC DBMS_STATS.GATHER_TABLE_STATS('scott', 'emp', no_invalidate =&gt; TRUE);

PL/SQL procedure successfully completed.
</code></pre>

<h2><code>SET_*_PREFS</code> プロシージャによりデフォルト値を変更する方法</h2>

<p>表単位でデフォルト値を変更する場合は <code>SET_TABLE_PREFS</code> プロシージャを使う。</p>

<p><code>GET_PREFS</code> プロシージャで現在の設定の確認。</p>

<pre><code>SQL&gt; SELECT DBMS_STATS.GET_PREFS('NO_INVALIDATE', 'scott', 'emp') FROM DUAL;

DBMS_STATS.GET_PREFS('NO_INVALIDATE','SCOTT','EMP')
---------------------------------------------------
DBMS_STATS.AUTO_INVALIDATE
</code></pre>

<p><code>SET_TABLE_PREFS</code> プロシージャにて設定の変更。</p>

<pre><code>SQL&gt; EXEC DBMS_STATS.SET_TABLE_PREFS('scott', 'emp', 'NO_INVALIDATE', 'TRUE');

PL/SQL procedure successfully completed.
</code></pre>

<p><code>GET_PREFS</code> プロシージャで設定が変更されたことを確認。</p>

<pre><code>SQL&gt; SELECT DBMS_STATS.GET_PREFS('NO_INVALIDATE', 'scott', 'emp') FROM DUAL;

DBMS_STATS.GET_PREFS('NO_INVALIDATE','SCOTT','EMP')
---------------------------------------------------
TRUE
</code></pre>

<p>あとは <code>no_invalidate</code> オプションを明示的に指定せずに統計情報を採取すると変更した内容がデフォルトとして採用される。</p>

<pre><code>SQL&gt; EXEC DBMS_STATS.GATHER_TABLE_STATS('scott', 'emp');

PL/SQL procedure successfully completed.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 複数列の統計]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-multicolumn-statistics/"/>
    <updated>2012-09-16T20:21:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-multicolumn-statistics</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>相関のある複数列を列グループとして統計情報採取することでよりよい実行計画となるようにする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
&ndash;> 13 オプティマイザ統計の管理<br/>
&ndash;> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/stats.htm#CIHFICCB">13.3.1.6 複数列の統計</a></li>
</ul>


<h2>複数列の統計収集</h2>

<p>相関のある複数列を列グループとして統計情報を採取することで、オプティマイザが個々の列でなく列グループとして実行計画を計算するようにする。</p>

<ul>
<li>検証で使用する表の作成</li>
</ul>


<p>C1 列、C2 列が同じになる(つまり相関がある)ような表を作成する。</p>

<pre><code>SQL&gt; CREATE TABLE multi_col_tab (c1 NUMBER, c2 NUMBER);

Table created.

SQL&gt; BEGIN
       FOR i IN 1..5 LOOP
         FOR j IN 1..100 LOOP
           INSERT INTO multi_col_tab VALUES(i, i);
         END LOOP;
       END LOOP;
       COMMIT;
     END;
     /

PL/SQL procedure successfully completed.
</code></pre>

<p>1 〜 5 までそれぞれ 100 行ずつ、計 500 行を INSERT。</p>

<ul>
<li>複数列統計を採取しない場合</li>
</ul>


<p>複数列統計を採取しない場合の実行計画</p>

<pre><code>SQL&gt; BEGIN
       DBMS_STATS.GATHER_TABLE_STATS(null,'MULTI_COL_TAB',
         METHOD_OPT =&gt; 'FOR ALL COLUMNS SIZE SKEWONLY');
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; set autotrace on
SQL&gt; SELECT COUNT(*) FROM multi_col_tab WHERE c1 = 1 AND c2 = 1;


  COUNT(*)
----------
       100


Execution Plan
----------------------------------------------------------
Plan hash value: 610516676

------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |    20 |   120 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("C1"=1 AND "C2"=1)


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          6  consistent gets
          0  physical reads
          0  redo size
        526  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>実行計画の <code>MULTI_COL_TAB</code> の出力行に注目</p>

<pre><code>------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |    20 |   120 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------
</code></pre>

<p><code>Rows</code> が 20 となっている。
条件が <code>WHERE c1 = 1 AND c2 = 1</code> だが、相関があることを知らないので、選択行が <code>500行 * 1/5(c1 の選択率) * 1/5(c2 の選択率)</code> = 20行 となっていて正確でない。</p>

<ul>
<li>複数列統計を採取した場合</li>
</ul>


<p>複数列統計を採取する。<code>c1</code> および <code>c2</code> 列で構成させる列グループを追加して、統計情報取得。</p>

<pre><code>SQL&gt; DECLARE
       cg_name varchar2(30);
     BEGIN
       cg_name := dbms_stats.create_extended_stats(null,'multi_col_tab',  
                 '(c1,c2)');
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; BEGIN
       DBMS_STATS.GATHER_TABLE_STATS(null,'MULTI_COL_TAB',
         METHOD_OPT =&gt; 'FOR ALL COLUMNS SIZE SKEWONLY');
     END;
     /

PL/SQL procedure successfully completed.
</code></pre>

<p>なお、<code>DBMS_STATS.CREATE_EXTENDED_STATS</code> で明示的に列グループを作成しない場合は、以下のように統計情報収集時に <code>METHOD_OPT</code> で複数列を指定してもよい。</p>

<pre><code>SQL&gt; BEGIN
       DBMS_STATS.GATHER_TABLE_STATS(null,'MULTI_COL_TAB',
         METHOD_OPT =&gt; 'FOR ALL COLUMNS SIZE SKEWONLY FOR COLUMNS (C1,C2) SIZE SKEWONLY');
     END;
     /

PL/SQL procedure successfully completed.
</code></pre>

<p>先ほどと同じ SQL で実行計画を確認してみる。</p>

<pre><code>SQL&gt; set autotrace on
SQL&gt; SELECT COUNT(*) FROM multi_col_tab WHERE c1 = 1 AND c2 = 1;

  COUNT(*)
----------
       100


Execution Plan
----------------------------------------------------------
Plan hash value: 610516676

------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |   100 |   600 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - filter("C1"=1 AND "C2"=1)


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          6  consistent gets
          0  physical reads
          0  redo size
        526  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>実行計画の <code>MULTI_COL_TAB</code> の出力行に注目</p>

<pre><code>------------------------------------------------------------------------------------
| Id  | Operation          | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |               |     1 |     6 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE    |               |     1 |     6 |            |          |
|*  2 |   TABLE ACCESS FULL| MULTI_COL_TAB |   100 |   600 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------
</code></pre>

<p><code>Rows</code> が 100 となっている。
条件が <code>WHERE c1 = 1 AND c2 = 1</code> で相関があることを認識して正確に 100 行と計算している。</p>

<ul>
<li>複数列統計の確認</li>
</ul>


<p>拡張統計として、複数列が認識されていることを確認。</p>

<pre><code>SQL&gt; col extension_name for a30
     col extension for a30
SQL&gt; Select extension_name, extension 
     from user_stat_extensions 
     where table_name='MULTI_COL_TAB';

EXTENSION_NAME                 EXTENSION
------------------------------ ------------------------------
SYS_STUF3GLKIOP5F4B0BTTCFTMX0W ("C1","C2")
</code></pre>

<p>実際に複数列の統計が採られていることを確認</p>

<pre><code>SQL&gt; col col_group for a30
SQL&gt; select e.extension col_group, t.num_distinct, t.histogram
     from user_stat_extensions e, user_tab_col_statistics t
     where e.extension_name=t.column_name
     and e.table_name=t.table_name
     and t.table_name='MULTI_COL_TAB';

COL_GROUP                      NUM_DISTINCT HISTOGRAM
------------------------------ ------------ ---------------------------------------------
("C1","C2")                               5 FREQUENCY
</code></pre>

<p><code>HISTGRAM</code> 列が <code>NONE</code> 以外であればヒストグラムが採られている。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] 結果キャッシュ]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-result-cache/"/>
    <updated>2012-09-16T18:40:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-result-cache</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>&ldquo;結果キャッシュ&rdquo; 機能を使用する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>パフォーマンス・チューニング・ガイド<br/>
&ndash;> 7 メモリーの構成および使用方法<br/>
&ndash;> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56312/memory.htm#BGBCABED">7.6 サーバーおよびクライアントの結果キャッシュの管理</a></li>
</ul>


<h2>結果キャッシュの使用</h2>

<p>&ldquo;結果キャッシュ&rdquo; 機能を使用することで、問い合わせ結果を再利用してパフォーマンスを向上させることができる。</p>

<ul>
<li>初期化パラメータの設定</li>
</ul>


<p>結果キャッシュを有効にするためには初期化パラメータ <code>RESULT_CACHE_MAX_SIZE</code> を 0 より大きくする必要がある。</p>

<p>0 の場合は結果キャッシュは無効となる。(以下のように <code>DBMS_RESULT_CACHE.STATUS</code> の結果が <code>DISABLED</code> となっている。)</p>

<pre><code>SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       0
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
DISABLED
</code></pre>

<p>初期化パラメータ <code>RESULT_CACHE_MAX_SIZE</code> は以下のように動的に変更できるが、実際はインスタンスを再起動しないと有効にならなかった。</p>

<pre><code>SQL&gt; ALTER SYSTEM SET result_cache_max_size = 15M SCOPE=both;

System altered.

SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       15M
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
DISABLED
</code></pre>

<p>インスタンスを再起動すると、有効になり、<code>DBMS_RESULT_CACHE.STATUS</code> も <code>ENABLED</code> に変わる。</p>

<pre><code>SQL&gt; shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL&gt; startup
ORACLE instance started.

Total System Global Area  835104768 bytes
Fixed Size                  2232960 bytes
Variable Size             734006656 bytes
Database Buffers           92274688 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.
SQL&gt; show parameter result_cache_max_size

NAME                                 TYPE                              VALUE
------------------------------------ --------------------------------- ------------------------------
result_cache_max_size                big integer                       15M
SQL&gt; SELECT DBMS_RESULT_CACHE.STATUS FROM DUAL;

STATUS
----------
ENABLED
</code></pre>

<ul>
<li>結果キャッシュの使用</li>
</ul>


<p>結果キャッシュを使用するには <code>/*+ RESULT_CACHE */</code> ヒントを付与して問い合わせを実行すればよい。</p>

<pre><code>SQL&gt; SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp;
</code></pre>

<ul>
<li>結果キャッシュの確認</li>
</ul>


<p>実行計画で、<code>RESULT CACHE</code> と出ていると結果キャッシュが使われている。</p>

<pre><code>SQL&gt; set lines 200
SQL&gt; set autotrace on
SQL&gt; SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp;

  AVG(SAL)
----------
2083.21429


Execution Plan
----------------------------------------------------------
Plan hash value: 2083865914

--------------------------------------------------------------------------------------------------
| Id  | Operation           | Name                       | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |                            |     1 |     4 |     3   (0)| 00:00:01 |
|   1 |  RESULT CACHE       | 4z1ag1pqa9zqm704zf4nuj9tq4 |       |       |            |          |
|   2 |   SORT AGGREGATE    |                            |     1 |     4 |            |          |
|   3 |    TABLE ACCESS FULL| EMP                        |    14 |    56 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------

Result Cache Information (identified by operation id):
------------------------------------------------------

   1 - column-count=1; dependencies=(SCOTT.EMP); attributes=(single-row); name="SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp"


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          0  consistent gets
          0  physical reads
          0  redo size
        545  bytes sent via SQL*Net to client
        523  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed
</code></pre>

<p>また、<code>V$RESULT_CACHE_OBJECTS</code> からも結果キャッシュについて確認できる。</p>

<pre><code>SQL&gt; SELECT type, status, name FROM v$result_cache_objects;

TYPE                           STATUS
------------------------------ ---------------------------
NAME
--------------------------------------------------------------------------------
Dependency                     Published
SCOTT.EMP

Result                         Published
SELECT /*+ RESULT_CACHE */ AVG(sal) FROM scott.emp
</code></pre>
]]></content>
  </entry>
  
</feed>
