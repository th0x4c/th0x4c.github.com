<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DB | th0x4c 備忘録]]></title>
  <link href="http://th0x4c.github.com/blog/categories/db/atom.xml" rel="self"/>
  <link href="http://th0x4c.github.com/"/>
  <updated>2012-09-16T15:56:03+09:00</updated>
  <id>http://th0x4c.github.com/</id>
  <author>
    <name><![CDATA[Takashi Hashizume]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Oracle] BasicFiles LOB から SecureFiles LOB への移行]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/16/oracle-securefiles-lob/"/>
    <updated>2012-09-16T14:15:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/16/oracle-securefiles-lob</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>従来型の LOB (BasicFiles LOB) から、Oracle Database 11g からの新しい LOB アーキテクチャである SecureFiles を使用した LOB へ移行する。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li><p>SecureFilesおよびラージ・オブジェクト開発者ガイド<br/>
-> 4 Oracle SecureFiles LOBの使用<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#BABDIEGE">BasicFiles LOBからSecureFiles LOBへの列の移行</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#BABJFEBB">SecureFiles LOBの初期化パラメータdb_securefile</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#CIHGHEFA">SecureFiles LOBを含んだCREATE TABLEの使用</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/appdev.112/b56263/adlob_smart.htm#CIHJJBIJ">SecureFiles LOBを含んだALTER TABLEの使用</a></p></li>
<li><p>管理者ガイド<br/>
-> 20 表の管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56301/tables007.htm#i1006754">表のオンライン再定義</a></p></li>
</ul>


<h2>BasicFiles LOB から SecureFiles LOB への移行</h2>

<p>Oracle Database 11g からの新しい LOB アーキテクチャである SecureFiles を使用した LOB を使用すると、以下のようなことが可能になる。</p>

<ul>
<li>圧縮(LOB データの圧縮)</li>
<li>重複除外(列内で重複する LOB データのコピーを1つのみ格納)</li>
<li>暗号化(透過的データ暗号化により LOB データを暗号化)</li>
</ul>


<p>従来型の LOB は、BasicFiles と呼ばれる。BasicFiles を使用した既存の LOB 列を SecureFiles に移行する。<code>ALTER TABLE</code> での BasicFiles から SecureFiles への変更はできないため、変更するためには表の再作成を行うか、オンライン再定義を行う必要がある。今回は、マニュアルに例があるように、オンライン再定義により行う。</p>

<ul>
<li>検証用に BasicFiles LOB 列を持つ表、データを準備</li>
</ul>


<p>BasicFiles LOB 列を持つ <code>cust</code> 表を作成してデータを insert。今回この表を SecureFiles LOB に移行してみる。</p>

<pre><code>SQL&gt; connect scott/tiger
SQL&gt; CREATE TABLE cust
     (
       c_id  NUMBER PRIMARY KEY,
       c_zip NUMBER,
       c_name VARCHAR(30) DEFAULT NULL,
       c_lob CLOB
     );

Table created.

SQL&gt; INSERT INTO cust VALUES(1, 94065, 'hhh', 'ttt');

1 row created.

SQL&gt; COMMIT;

Commit complete.
</code></pre>

<ul>
<li>オンライン再定義に必要な権限の付与</li>
</ul>


<p>オンライン再定義に必要な権限を与える</p>

<pre><code>SQL&gt; connect /as sysdba
SQL&gt; -- Grant privileges required for online redefinition.
SQL&gt; GRANT EXECUTE ON DBMS_REDEFINITION TO scott;
SQL&gt; GRANT ALTER ANY TABLE TO scott;
SQL&gt; GRANT DROP ANY TABLE TO scott;
SQL&gt; GRANT LOCK ANY TABLE TO scott;
SQL&gt; GRANT CREATE ANY TABLE TO scott;
SQL&gt; GRANT SELECT ANY TABLE TO scott;
SQL&gt; -- Privileges required to perform cloning of dependent objects.
SQL&gt; GRANT CREATE ANY TRIGGER TO scott;
SQL&gt; GRANT CREATE ANY INDEX TO scott;
</code></pre>

<ul>
<li>初期化パラメータ <code>db_securefile</code> パラメータの変更</li>
</ul>


<p>SecureFiles LOB の初期化パラメータ <code>db_securefile</code> パラメータを変更する。
SecureFiles LOB を使用するためには <code>PERMITTED</code> (デフォルト) または <code>ALWAYS</code> である必要がある。</p>

<p>例えば、<code>NEVER</code> に設定されている場合に SecureFiles LOB の列を作成しようとすると、<code>ORA-43856</code> が発生する。</p>

<pre><code>SQL&gt; CREATE TABLE test_lob (c_lob CLOB) LOB(c_lob) STORE AS SECUREFILE (compress high);
CREATE TABLE test_lob (c_lob CLOB) LOB(c_lob) STORE AS SECUREFILE (compress high)
*
ERROR at line 1:
ORA-43856: Unsupported LOB type for SECUREFILE LOB operation
</code></pre>

<p><code>db_securefile</code> を <code>ALTER SYSTEM</code> で変更する。</p>

<pre><code>SQL&gt; conn /as sysdba
Connected.
SQL&gt; ALTER SYSTEM SET db_securefile = PERMITTED SCOPE=both;

System altered.
</code></pre>

<ul>
<li>仮表を作成</li>
</ul>


<p>オンライン再定義のための仮表を SecureFiles LOB 列を持つようにして作成。元表からコピーされるので主キーなどの制約の指定は不要。</p>

<pre><code>SQL&gt; connect scott/tiger
Connected.
SQL&gt; CREATE TABLE cust_int
     (
       c_id  NUMBER,
       c_zip NUMBER,
       c_name VARCHAR(30) DEFAULT NULL,
       c_lob CLOB
     )
     LOB(c_lob) STORE AS SECUREFILE;

Table created.
</code></pre>

<ul>
<li>表のオンライン再定義</li>
</ul>


<p>表のオンライン再定義を実行する。</p>

<pre><code>SQL&gt; DECLARE
       col_mapping VARCHAR2(1000);
     BEGIN
       -- map all the columns in the interim table to the original table
       col_mapping :=
         'c_id c_id , '||
         'c_zip c_zip , '||
         'c_name c_name, '||
         'c_lob c_lob';
       DBMS_REDEFINITION.START_REDEF_TABLE('scott', 'cust', 'cust_int', col_mapping);
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; set serveroutput on
SQL&gt; DECLARE
       error_count pls_integer := 0;
     BEGIN
       DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS('scott', 'cust', 'cust_int',
         1, TRUE,TRUE,TRUE,FALSE, error_count);
       DBMS_OUTPUT.PUT_LINE('errors := ' || TO_CHAR(error_count));
     END;
     /
errors := 0

PL/SQL procedure successfully completed.

SQL&gt; EXEC DBMS_REDEFINITION.FINISH_REDEF_TABLE('scott', 'cust', 'cust_int');

PL/SQL procedure successfully completed.

SQL&gt; DROP TABLE cust_int;

Table dropped.
</code></pre>

<ul>
<li>SecureFiles LOB に移行されたことを確認</li>
</ul>


<p><code>USER_LOBS.SECUREFILE</code> 列が <code>YES</code> であれば SecureFiles になっている。</p>

<pre><code>SQL&gt; col table_name for a30
SQL&gt; col column_name for a30
SQL&gt; SELECT table_name, column_name, securefile FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    SECUREFIL
------------------------------ ------------------------------ ---------
CUST                           C_LOB                          YES
</code></pre>

<h2>SecureFiles LOB の変更</h2>

<p><code>ALTER TABLE</code> 文により既存の SecureFiles LOB 列を変更して、圧縮や重複除外の設定を行う。</p>

<ul>
<li>現在の設定の確認</li>
</ul>


<p><code>USER_LOBS</code> にて確認できる。</p>

<pre><code>SQL&gt; col table_name for a30
     col column_name for a30
     col encrypt for a10
     col compression for a15
     col deduplication for a15
     set lines 200
SQL&gt; SELECT table_name, column_name, encrypt, compression, deduplication FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    ENCRYPT    COMPRESSION     DEDUPLICATION
------------------------------ ------------------------------ ---------- --------------- ---------------
CUST                           C_LOB                          NO         NO              NO
</code></pre>

<ul>
<li>設定の変更</li>
</ul>


<p><code>ALTER TABLE</code> により圧縮、重複除外の設定を行う。</p>

<pre><code>SQL&gt; ALTER TABLE cust MODIFY LOB(c_lob) (COMPRESS HIGH);

Table altered.

SQL&gt; ALTER TABLE cust MODIFY LOB(c_lob) (DEDUPLICATE);

Table altered.
</code></pre>

<ul>
<li>設定変更の確認</li>
</ul>


<p><code>USER_LOBS</code> にて確認。</p>

<pre><code>SQL&gt; col table_name for a30
     col column_name for a30
     col encrypt for a10
     col compression for a15
     col deduplication for a15
     set lines 200
SQL&gt; SELECT table_name, column_name, encrypt, compression, deduplication FROM user_lobs;

TABLE_NAME                     COLUMN_NAME                    ENCRYPT    COMPRESSION     DEDUPLICATION
------------------------------ ------------------------------ ---------- --------------- ---------------
CUST                           C_LOB                          NO         HIGH            LOB
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] スター型変換の使用]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/13/oracle-star-transformation/"/>
    <updated>2012-09-13T01:14:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/13/oracle-star-transformation</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>スター型変換を行い、スター・クエリーをチューニングする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>データ・ウェアハウス・ガイド<br/>
-> 20 スキーマのモデリング化技法<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/schemas.htm#CIHGHEFB">スター・クエリーの最適化</a></li>
</ul>


<h2>スター型変換を使用したスター・クエリーのチューニング</h2>

<p>スター型変換を行い、スター・クエリーをチューニングする。
スター・クエリーは1つの大規模なファクト表と、複数の小規模なディメンション表を結合するようなクエリー。ファクト表が大きいため、ファクト表をなるべく条件を絞り込んだ後でアクセスするような特別な結合(スター結合)をしたほうが効率がよい。このために暗黙的に SQL をリライト(または変換)する機能をスター型変換という。</p>

<p>スター型変換を行うためには、以下に従う必要がある。</p>

<ol>
<li>ビットマップ索引をファクト表の各外部キー列上に作成する必要がある。</li>
<li>初期化パラメータ <code>STAR_TRANSFORMATION_ENABLED</code> を <code>TRUE</code> に設定する必要がある。</li>
</ol>


<p>検証してみる。</p>

<ul>
<li>表、データを準備</li>
</ul>


<p>ディメンション表 <code>jobs</code>, <code>dates</code>, ファクト表 <code>emp_fact</code> を作成</p>

<pre><code>$ sqlplus scott/tiger
SQL&gt; -- ディメンション表 jobs
SQL&gt; CREATE TABLE jobs
     AS SELECT rownum job_id, job
     FROM (SELECT DISTINCT job FROM emp);

Table created.

SQL&gt; ALTER TABLE jobs ADD (CONSTRAINT jobs_pk PRIMARY KEY (job_id) VALIDATE);

Table altered.

SQL&gt; -- ディメンション表 dates
SQL&gt; CREATE TABLE dates
     AS SELECT rownum date_id, hiredate, to_char(hiredate, 'YYYY') year
     FROM (SELECT DISTINCT hiredate FROM emp);

Table created.

SQL&gt; ALTER TABLE dates ADD (CONSTRAINT dates_pk PRIMARY KEY (date_id) VALIDATE);

Table altered.

SQL&gt; -- ファクト表 emp_fact
SQL&gt; CREATE TABLE emp_fact
     AS SELECT e.empno, e.ename, j.job_id, e.mgr, d.date_id, e.sal, e.comm, e.deptno
     FROM emp e, dates d, jobs j
     WHERE e.job = j.job AND e.hiredate = d.hiredate;

Table created.

SQL&gt; ALTER TABLE emp_fact ADD (CONSTRAINT emp_fact_jobs_fk FOREIGN KEY(job_id) REFERENCES jobs(job_id) VALIDATE);

Table altered.

SQL&gt; ALTER TABLE emp_fact ADD (CONSTRAINT emp_fact_dates_fk FOREIGN KEY(date_id) REFERENCES dates(date_id) VALIDATE);

Table altered.

SQL&gt; -- データロード
SQL&gt; INSERT INTO emp_fact SELECT * FROM emp_fact;

14 rows created.

SQL&gt; /

28 rows created.
...(以下繰り返す)

SQL&gt; /

114688 rows created.

SQL&gt; COMMIT;

Commit complete.

SQL&gt; -- 統計情報取得
SQL&gt; EXEC DBMS_STATS.GATHER_SCHEMA_STATS('scott');

PL/SQL procedure successfully completed.
</code></pre>

<ul>
<li>スター変換の確認方法</li>
</ul>


<p>スター変換されているかどうかは <code>set autotrace trace exp</code> 等の実行計画から確認する。
例えば <code>set autotrace trace exp</code> で <code>Note</code> に以下の出力があればスター変換されている。</p>

<pre><code>Note 
-----
   - star transformation used for this statement
</code></pre>

<p>ちなみに <code>set autotrace</code> を使用するためには <code>PLUSTRACE</code> ロールが必要で、以下のように作成する。</p>

<pre><code>SQL&gt; connect /as sysdba              
Connected.
SQL&gt; @?/sqlplus/admin/plustrce.sql

SQL&gt; GRANT plustrace TO scott;

Grant succeeded.
</code></pre>

<ul>
<li>スター変換なしの場合</li>
</ul>


<p>以下の SELECT 文で試してみる。</p>

<pre><code>SQL&gt; set timing on
SQL&gt; set autotrace on
SQL&gt; set lines 200
SQL&gt; SELECT j.job, d.year, SUM(e.sal), d.dname
     FROM emp_fact e, jobs j, dates d, dept d
     WHERE e.job_id = j.job_id
     AND   e.date_id = d.date_id
     AND   e.deptno = d.deptno
     AND   j.job = 'CLERK'
     AND   d.year in ('1980', '1987')
     GROUP BY j.job, d.year, d.dname;

JOB                         YEAR         SUM(E.SAL) DNAME
--------------------------- ------------ ---------- ------------------------------------------
CLERK                       1987           18022400 RESEARCH
CLERK                       1980           13107200 RESEARCH

Elapsed: 00:00:00.04

Execution Plan
----------------------------------------------------------
Plan hash value: 3373499036

------------------------------------------------------------------------------------
| Id  | Operation               | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT        |          |     4 |   180 |   324   (3)| 00:00:04 |
|   1 |  HASH GROUP BY          |          |     4 |   180 |   324   (3)| 00:00:04 |
|*  2 |   HASH JOIN             |          | 22938 |  1008K|   323   (2)| 00:00:04 |
|   3 |    TABLE ACCESS FULL    | DEPT     |     4 |    52 |     3   (0)| 00:00:01 |
|*  4 |    HASH JOIN            |          | 22938 |   716K|   319   (2)| 00:00:04 |
|   5 |     MERGE JOIN CARTESIAN|          |     7 |   133 |     6   (0)| 00:00:01 |
|*  6 |      TABLE ACCESS FULL  | JOBS     |     1 |    11 |     3   (0)| 00:00:01 |
|   7 |      BUFFER SORT        |          |     7 |    56 |     3   (0)| 00:00:01 |
|*  8 |       TABLE ACCESS FULL | DATES    |     7 |    56 |     3   (0)| 00:00:01 |
|   9 |     TABLE ACCESS FULL   | EMP_FACT |   229K|  2912K|   312   (2)| 00:00:04 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("E"."DEPTNO"="D"."DEPTNO")
   4 - access("E"."JOB_ID"="J"."JOB_ID" AND "E"."DATE_ID"="D"."DATE_ID")
   6 - filter("J"."JOB"='CLERK')
   8 - filter("D"."YEAR"='1980' OR "D"."YEAR"='1987')


Statistics
----------------------------------------------------------
          0  recursive calls
          1  db block gets
       1098  consistent gets
          0  physical reads
          0  redo size
        824  bytes sent via SQL*Net to client
        524  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
          2  rows processed
</code></pre>

<p>0.04 秒かかっている。</p>

<ul>
<li>スター型変換</li>
</ul>


<p>スター型変換するようにビットマップ索引を作成し、初期化パラメータ<code>ALTER SESSION SET STAR_TRANSFORMATION_ENABLED</code> を <code>TRUE</code> にして再実行する。</p>

<pre><code>SQL&gt; -- ビットマップ索引を作成
SQL&gt; CREATE BITMAP INDEX emp_fact_job_bix ON emp_fact(job_id);

Index created.

SQL&gt; CREATE BITMAP INDEX emp_fact_date_bix ON emp_fact(date_id);

Index created.

SQL&gt; CREATE BITMAP INDEX emp_fact_dept_bix ON emp_fact(deptno);

Index created.

SQL&gt; -- 統計情報採取
SQL&gt; EXEC DBMS_STATS.GATHER_SCHEMA_STATS('scott');

PL/SQL procedure successfully completed.

SQL&gt; -- 初期化パラメータ変更
SQL&gt; SQL&gt; ALTER SESSION SET STAR_TRANSFORMATION_ENABLED = TRUE

Session altered.
</code></pre>

<p>先ほどと同じ SELECT を実行する。</p>

<pre><code>SQL&gt; set timing on
SQL&gt; set autotrace on
SQL&gt; set lines 200
SQL&gt; SELECT j.job, d.year, SUM(e.sal), d.dname
     FROM emp_fact e, jobs j, dates d, dept d
     WHERE e.job_id = j.job_id
     AND   e.date_id = d.date_id
     AND   e.deptno = d.deptno
     AND   j.job = 'CLERK'
     AND   d.year in ('1980', '1987')
     GROUP BY j.job, d.year, d.dname;

JOB                         YEAR         SUM(E.SAL) DNAME
--------------------------- ------------ ---------- ------------------------------------------
CLERK                       1987           18022400 RESEARCH
CLERK                       1980           13107200 RESEARCH

Elapsed: 00:00:00.02

Execution Plan
----------------------------------------------------------
Plan hash value: 4243144607

------------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                   |     4 |   216 |   322   (1)| 00:00:04 |
|   1 |  HASH GROUP BY                   |                   |     4 |   216 |   322   (1)| 00:00:04 |
|*  2 |   HASH JOIN                      |                   |  8823 |   465K|   321   (1)| 00:00:04 |
|   3 |    TABLE ACCESS FULL             | DEPT              |     4 |    52 |     3   (0)| 00:00:01 |
|*  4 |    HASH JOIN                     |                   |  8823 |   353K|   318   (1)| 00:00:04 |
|   5 |     MERGE JOIN CARTESIAN         |                   |     3 |    57 |     6   (0)| 00:00:01 |
|*  6 |      TABLE ACCESS FULL           | JOBS              |     1 |    11 |     3   (0)| 00:00:01 |
|   7 |      BUFFER SORT                 |                   |     3 |    24 |     3   (0)| 00:00:01 |
|*  8 |       TABLE ACCESS FULL          | DATES             |     3 |    24 |     3   (0)| 00:00:01 |
|   9 |     VIEW                         | VW_ST_7A68B670    | 10587 |   227K|   311   (0)| 00:00:04 |
|  10 |      NESTED LOOPS                |                   | 10587 |   444K|   305   (0)| 00:00:04 |
|  11 |       BITMAP CONVERSION TO ROWIDS|                   | 10586 |   186K|     6   (0)| 00:00:01 |
|  12 |        BITMAP AND                |                   |       |       |            |          |
|  13 |         BITMAP MERGE             |                   |       |       |            |          |
|  14 |          BITMAP KEY ITERATION    |                   |       |       |            |          |
|* 15 |           TABLE ACCESS FULL      | JOBS              |     1 |    11 |     3   (0)| 00:00:01 |
|* 16 |           BITMAP INDEX RANGE SCAN| EMP_FACT_JOB_BIX  |       |       |            |          |
|  17 |         BITMAP MERGE             |                   |       |       |            |          |
|  18 |          BITMAP KEY ITERATION    |                   |       |       |            |          |
|* 19 |           TABLE ACCESS FULL      | DATES             |     3 |    24 |     3   (0)| 00:00:01 |
|* 20 |           BITMAP INDEX RANGE SCAN| EMP_FACT_DATE_BIX |       |       |            |          |
|  21 |       TABLE ACCESS BY USER ROWID | EMP_FACT          |     1 |    25 |   305   (1)| 00:00:04 |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("ITEM_1"="D"."DEPTNO")
   4 - access("ITEM_3"="J"."JOB_ID" AND "ITEM_2"="D"."DATE_ID")
   6 - filter("J"."JOB"='CLERK')
   8 - filter("D"."YEAR"='1980' OR "D"."YEAR"='1987')
  15 - filter("J"."JOB"='CLERK')
  16 - access("E"."JOB_ID"="J"."JOB_ID")
  19 - filter("D"."YEAR"='1980' OR "D"."YEAR"='1987')
  20 - access("E"."DATE_ID"="D"."DATE_ID")

Note
-----
   - star transformation used for this statement


Statistics
----------------------------------------------------------
          1  recursive calls
          0  db block gets
       1075  consistent gets
          0  physical reads
          0  redo size
        824  bytes sent via SQL*Net to client
        524  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          1  sorts (memory)
          0  sorts (disk)
          2  rows processed
</code></pre>

<p>今回は、<code>star transformation used for this statement</code> の出力があるようにスター型変換されており、実行時間も 0.02秒と改善されている。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle トランスポータブル表領域]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/12/oracle-transportable-tablespace/"/>
    <updated>2012-09-12T23:18:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/12/oracle-transportable-tablespace</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>トランスポータブル表領域により DB 間で表領域の移動を行う。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>管理者ガイド<br/>
-> 14 表領域の管理<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56301/tspaces013.htm#i1007252">データベース間で表領域をトランスポートする手順および例</a></li>
</ul>


<h2>トランスポータブル表領域</h2>

<p>マニュアルに記載の手順に従い、トランスポータブル表領域により DB 間で表領域の移動を行う。</p>

<ul>
<li>今回の検証用に表領域を作成</li>
</ul>


<p><code>tt_emp</code> 表領域を作成する。</p>

<pre><code>SQL&gt; CREATE TABLESPACE tt_emp
     DATAFILE '/u01/app/oracle/oradata/PROD1/tt_emp01.dbf'
     SIZE 10M REUSE AUTOEXTEND ON;

Tablespace created.

SQL&gt; CREATE TABLE scott.tt_emp TABLESPACE tt_emp AS SELECT * FROM scott.emp;

Table created.
</code></pre>

<ul>
<li>endianness の確認</li>
</ul>


<p>異なるプラットフォーム間で表領域のトランスポートを行う場合は endianness が異なると変換が必要になる。
endianness を確認する。</p>

<pre><code>SQL&gt; set pages 100
     col platform_name for a40
     col endian_format for a15
SQL&gt; SELECT * FROM V$TRANSPORTABLE_PLATFORM;

PLATFORM_ID PLATFORM_NAME                            ENDIAN_FORMAT
----------- ---------------------------------------- ---------------
          1 Solaris[tm] OE (32-bit)                  Big
          2 Solaris[tm] OE (64-bit)                  Big
          7 Microsoft Windows IA (32-bit)            Little
         10 Linux IA (32-bit)                        Little
          6 AIX-Based Systems (64-bit)               Big
          3 HP-UX (64-bit)                           Big
          5 HP Tru64 UNIX                            Little
          4 HP-UX IA (64-bit)                        Big
         11 Linux IA (64-bit)                        Little
         15 HP Open VMS                              Little
          8 Microsoft Windows IA (64-bit)            Little
          9 IBM zSeries Based Linux                  Big
         13 Linux x86 64-bit                         Little
         16 Apple Mac OS                             Big
         12 Microsoft Windows x86 64-bit             Little
         17 Solaris Operating System (x86)           Little
         18 IBM Power Based Linux                    Big
         19 HP IA Open VMS                           Little
         20 Solaris Operating System (x86-64)        Little
         21 Apple Mac OS (x86-64)                    Little

20 rows selected.

SQL&gt; SELECT PLATFORM_NAME FROM V$DATABASE;

PLATFORM_NAME
----------------------------------------
Linux x86 64-bit

SQL&gt; SELECT d.PLATFORM_NAME, ENDIAN_FORMAT
     FROM V$TRANSPORTABLE_PLATFORM tp, V$DATABASE d
     WHERE tp.PLATFORM_NAME = d.PLATFORM_NAME;

PLATFORM_NAME                            ENDIAN_FORMAT
---------------------------------------- ---------------
Linux x86 64-bit                         Little
</code></pre>

<ul>
<li>表領域が自己完結型かどうかの確認</li>
</ul>


<p>表領域内に別の表領域の表の索引が含まれている場合などは自己完結型でないためトランスポートできない。
表領域が自己完結型かどうかチェックする。</p>

<pre><code>SQL&gt; EXECUTE DBMS_TTS.TRANSPORT_SET_CHECK('tt_emp', TRUE);

PL/SQL procedure successfully completed.

SQL&gt; SELECT * FROM TRANSPORT_SET_VIOLATIONS;

no rows selected
</code></pre>

<p>もし、違反している場合は <code>TRANSPORT_SET_VIOLATIONS</code> ビューに違反している内容が表示される。</p>

<ul>
<li>表領域を読み取り専用にする</li>
</ul>


<p>表領域を読取り専用にする。</p>

<pre><code>SQL&gt; ALTER TABLESPACE tt_emp READ ONLY;

Tablespace altered.
</code></pre>

<ul>
<li>データ・ポンプによりエクスポート</li>
</ul>


<p><code>expdp</code> によりエクスポートする。</p>

<pre><code>$ expdp system/oracle dumpfile=expdat.dmp directory=data_pump_dir \
        transport_tablespaces=tt_emp logfile=tts_export.log

Export: Release 11.2.0.3.0 - Production on Wed Sep 12 23:53:49 2012

Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.

Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
FLASHBACK automatically enabled to preserve database integrity.
Starting "SYSTEM"."SYS_EXPORT_TRANSPORTABLE_01":  system/******** dumpfile=expdat.dmp directory=data_pump_dir transport_tablespaces=tt_emp logfile=tts_export.log 
Processing object type TRANSPORTABLE_EXPORT/PLUGTS_BLK
Processing object type TRANSPORTABLE_EXPORT/TABLE
Processing object type TRANSPORTABLE_EXPORT/POST_INSTANCE/PLUGTS_BLK
Master table "SYSTEM"."SYS_EXPORT_TRANSPORTABLE_01" successfully loaded/unloaded
******************************************************************************
Dump file set for SYSTEM.SYS_EXPORT_TRANSPORTABLE_01 is:
  /u01/app/oracle/admin/PROD1/dpdump/expdat.dmp
******************************************************************************
Datafiles required for transportable tablespace TT_EMP:
  /u01/app/oracle/oradata/PROD1/tt_emp01.dbf
Job "SYSTEM"."SYS_EXPORT_TRANSPORTABLE_01" successfully completed at 23:54:17
</code></pre>

<ul>
<li>endianness の変換</li>
</ul>


<p>もし、endianness の異なるプラットフォームにトランスポートする場合は、RMAN でデータファイルの変換を行う。</p>

<pre><code>$ export ORACLE_SID=PROD1
$ rman target /
RMAN&gt; CONVERT TABLESPACE tt_emp
      TO PLATFORM 'Apple Mac OS'
      FORMAT '/tmp/%U';

Starting conversion at source at 12-09-12
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=43 device type=DISK
channel ORA_DISK_1: starting datafile conversion
input datafile file number=00006 name=/u01/app/oracle/oradata/PROD1/tt_emp01.dbf
converted datafile=/tmp/data_D-PROD1_I-2014160803_TS-TT_EMP_FNO-6_07nl25cg
channel ORA_DISK_1: datafile conversion complete, elapsed time: 00:00:01
Finished conversion at source at 12-09-12  
</code></pre>

<ul>
<li>表領域のデータファイルと、エクスポート・ダンプ・ファイルをトランスポート先に移動</li>
</ul>


<p>今回は同一サーバ上の別 DB にした。</p>

<pre><code># エクスポート・ダンプ・ファイル をトランスポート先 DB の DATA_PUMP_DIR にコピー
$ cp -i /u01/app/oracle/admin/PROD1/dpdump/expdat.dmp /u01/app/oracle/admin/PROD2/dpdump/

# 通常はデータファイルをトランスポート先のデータファイルの位置にコピー
# 今回はテストとして endianness を変換したファイルをコピーした
$ cp -i /tmp/data_D-PROD1_I-2014160803_TS-TT_EMP_FNO-6_07nl25cg /tmp/tt_emp01.dbf
</code></pre>

<ul>
<li>endianness の変換</li>
</ul>


<p>もし、endianness の異なるプラットフォームにトランスポートする場合でトランスポート元で変換を行っていない場合は、RMAN でデータファイルの変換を行う。</p>

<pre><code>$ export ORACLE_SID=PROD2
$ rman target /
RMAN&gt; CONVERT DATAFILE
      '/tmp/tt_emp01.dbf'
      TO PLATFORM 'Linux x86 64-bit'
      FROM PLATFORM 'Apple Mac OS'
      DB_FILE_NAME_CONVERT='/tmp/', '/u01/app/oracle/oradata/PROD2/';

Starting conversion at target at 12-09-13
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=36 device type=DISK
channel ORA_DISK_1: starting datafile conversion
input file name=/tmp/tt_emp01.dbf
converted datafile=/u01/app/oracle/oradata/PROD2/tt_emp01.dbf
channel ORA_DISK_1: datafile conversion complete, elapsed time: 00:00:01
Finished conversion at target at 12-09-13
</code></pre>

<ul>
<li>トランスポート元の表領域を読取り/書込みモードに戻す。</li>
</ul>


<p><code>ALTER TABLESPACE</code> にて戻す。</p>

<pre><code>$ export ORACLE_SID=PROD1
$ sqlplus '/as sysdba'
SQL&gt; ALTER TABLESPACE tt_emp READ WRITE;

Tablespace altered.
</code></pre>

<ul>
<li>データ・ポンプによりインポート</li>
</ul>


<p><code>impdp</code> によりインポートする。</p>

<pre><code>$ export ORACLE_SID=PROD2
$ impdp system/oracle dumpfile=expdat.dmp directory=data_pump_dir \
        transport_datafiles='/u01/app/oracle/oradata/PROD2/tt_emp01.dbf' \
        logfile=tts_import.log

Import: Release 11.2.0.3.0 - Production on Thu Sep 13 00:22:31 2012

Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.

Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
Master table "SYSTEM"."SYS_IMPORT_TRANSPORTABLE_01" successfully loaded/unloaded
Starting "SYSTEM"."SYS_IMPORT_TRANSPORTABLE_01":  system/******** dumpfile=expdat.dmp directory=data_pump_dir transport_datafiles=/u01/app/oracle/oradata/PROD2/tt_emp01.dbf logfile=tts_import.log 
Processing object type TRANSPORTABLE_EXPORT/PLUGTS_BLK
Processing object type TRANSPORTABLE_EXPORT/TABLE
Processing object type TRANSPORTABLE_EXPORT/POST_INSTANCE/PLUGTS_BLK
Job "SYSTEM"."SYS_IMPORT_TRANSPORTABLE_01" successfully completed at 00:22:34
</code></pre>

<ul>
<li>トランスポート先の表領域を読取り/書込みモードに戻す。</li>
</ul>


<p><code>ALTER TABLESPACE</code> にて戻す。</p>

<pre><code>$ export ORACLE_SID=PROD2
$ sqlplus '/as sysdba'
SQL&gt; ALTER TABLESPACE tt_emp READ WRITE;

Tablespace altered.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] マテリアライズド・ビューの高速リフレッシュ]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/12/oracle-fast-refresh-on-materialized-view/"/>
    <updated>2012-09-12T21:14:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/12/oracle-fast-refresh-on-materialized-view</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>集計(<code>AVG(sal)</code> など)や結合(<code>emp.deptno = dept.deptno</code> など)を含むマテリアライズド・ビューを高速リフレッシュ可能にする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
</ul>


<h2>マニュアル</h2>

<ul>
<li>データ・ウェアハウス・ガイド<br/>
-> 9 基本的なマテリアライズド・ビュー<br/>
-> <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1006519">集計を含むマテリアライズド・ビュー</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1007028">集計を含むマテリアライズド・ビューの高速リフレッシュに関する制限</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1006674">結合のみを含むマテリアライズド・ビュー</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#i1007013">結合のみを含むマテリアライズド・ビューの高速リフレッシュに関する制限</a><br/>
   <a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#sthref257">DBMS_MVIEW.EXPLAIN_MVIEWプロシージャの使用</a></li>
</ul>


<h2>集計を含むマテリアライズド・ビュー</h2>

<p>集計(<code>AVG(sal)</code> など)を含むマテリアライズド・ビューを高速リフレッシュ可能にする。</p>

<p>マニュアルから、集計関数(<code>SUM</code>, <code>COUNT(*)</code>, <code>AVG</code> など)を含むマテリアライズド・ビューを高速リフレッシュ可能にするためにはいくつか制限がある。
ざっくり含める必要がある要件をまとめると以下。</p>

<ul>
<li><p>マテリアライズド・ビュー・ログの要件</p>

<ul>
<li>マテリアライズド・ビューで参照される列をすべて含める</li>
<li><code>ROWID</code> および <code>INCLUDING NEW VALUES</code> 句を指定</li>
<li>表の更新を行う場合は <code>SEQUENCE</code> 句を指定</li>
</ul>
</li>
<li><p>マテリアライズド・ビューの SELECT 文に含める要件</p>

<ul>
<li><code>COUNT(*)</code> を含める</li>
<li><code>AVG(expr)</code> などの集計ごとに、対応する <code>COUNT(expr)</code> および <code>SUM(expr)</code> を含める。(<a href="http://docs.oracle.com/cd/E16338_01/server.112/b56309/basicmv.htm#sthref182">集計関数によって要件は異なる</a>)</li>
</ul>
</li>
</ul>


<p>例えば以下の SELECT を含むマテリアライズド・ビューを考える。</p>

<pre><code>SELECT d.dname, AVG(e.sal) avg_sal
FROM emp e, dept d
WHERE e.deptno = d.deptno
GROUP BY d.dname;
</code></pre>

<p>高速リフレッシュ可能なマテリアライズド・ビューを作成する。</p>

<ul>
<li>マテリアライズド・ビュー・ログの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW LOG</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW LOG ON emp
     WITH SEQUENCE, ROWID
     (sal, deptno)
     INCLUDING NEW VALUES;

Materialized view log created.

SQL&gt; CREATE MATERIALIZED VIEW LOG ON dept
     WITH SEQUENCE, ROWID
     (deptno, dname)
     INCLUDING NEW VALUES;

Materialized view log created.
</code></pre>

<ul>
<li>マテリアライズド・ビューの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW emp_dept_mv
     BUILD IMMEDIATE
     REFRESH FAST
     ENABLE QUERY REWRITE
     AS SELECT d.dname, AVG(e.sal) avg_sal,
               COUNT(*) cnt, COUNT(e.sal) cnt_sal, SUM(e.sal) sum_sal
     FROM emp e, dept d
     WHERE e.deptno = d.deptno
     GROUP BY d.dname;

Materialized view created.
</code></pre>

<h2>高速リフレッシュ可能か確認する方法</h2>

<p><code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャを使用することで簡単にマテリアライズド・ビューに関して次のことを確認できる。</p>

<ul>
<li>高速リフレッシュ可能かどうか</li>
<li>実行できるクエリー・リライトのタイプ</li>
<li>PCT リフレッシュ(パーティション単位での高速リフレッシュ)が可能かどうか(パーティション表でないと意味なし)</li>
</ul>


<p>使い方は以下</p>

<ol>
<li><code>$ORACLE_HOME/rdbms/admin/utlxmv.sql</code> を流して <code>MV_CAPABILITIES_TABLE</code> 表を作成</li>
<li><code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャの引数にマテリアライズド・ビュー名かマテリアライズド・ビューで使用している SELECT 文を与えて実行</li>
<li><code>MV_CAPABILITIES_TABLE</code> 表を SELECT して確認</li>
<li>再度 <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャを実行する場合は <code>TRUNCATE TABLE MV_CAPABILITIES_TABLE</code> で結果をクリア</li>
</ol>


<p>先ほど作成したマテリアライズド・ビューで確認してみる。</p>

<pre><code>SQL&gt; @?/rdbms/admin/utlxmv.sql

Table created.

SQL&gt; EXEC DBMS_MVIEW.EXPLAIN_MVIEW('emp_dept_mv');

PL/SQL procedure successfully completed.

SQL&gt; set lines 200
     set pages 100
     col capability_name for a30
     col rel_text for a10
     col msgtxt for a60
SQL&gt; SELECT capability_name,  possible, SUBSTR(related_text,1,8)
       AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
     FROM MV_CAPABILITIES_TABLE
     ORDER BY seq;

CAPABILITY_NAME                POS REL_TEXT   MSGTXT
------------------------------ --- ---------- ------------------------------------------------------------
PCT                            N
REFRESH_COMPLETE               Y
REFRESH_FAST                   Y
REWRITE                        Y
PCT_TABLE                      N   EMP        relation is not a partitioned table
PCT_TABLE                      N   DEPT       relation is not a partitioned table
REFRESH_FAST_AFTER_INSERT      Y
REFRESH_FAST_AFTER_ONETAB_DML  Y
REFRESH_FAST_AFTER_ANY_DML     Y
REFRESH_FAST_PCT               N              PCT is not possible on any of the detail tables in the mater
REWRITE_FULL_TEXT_MATCH        Y
REWRITE_PARTIAL_TEXT_MATCH     Y
REWRITE_GENERAL                Y
REWRITE_PCT                    N              general rewrite is not possible or PCT is not possible on an
PCT_TABLE_REWRITE              N   EMP        relation is not a partitioned table
PCT_TABLE_REWRITE              N   DEPT       relation is not a partitioned table

16 rows selected.
</code></pre>

<p><code>possible</code> 列が <code>Y</code> であることから高速リフレッシュ可能であることが分かる。(<code>PCT*</code> に関してはパーティション表ではないので無視)</p>

<p>例えば、以下のようにマテリアライズド・ビュー作成前に高速リフレッシュ可能か確認でき、可能でない場合は理由を表示してくれる。</p>

<pre><code>SQL&gt; TRUNCATE TABLE MV_CAPABILITIES_TABLE;

Table truncated.

SQL&gt; -- わざと COUNT(e.sal), SUM(e.sal) を外してみる
SQL&gt; BEGIN
       DBMS_MVIEW.EXPLAIN_MVIEW('
         SELECT d.dname, AVG(e.sal) avg_sal,
                COUNT(*) cnt
         FROM emp e, dept d
         WHERE e.deptno = d.deptno
         GROUP BY d.dname');
     END;
     /

PL/SQL procedure successfully completed.

SQL&gt; SELECT capability_name,  possible, SUBSTR(related_text,1,8)
       AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
     FROM MV_CAPABILITIES_TABLE
     ORDER BY seq;

CAPABILITY_NAME                POS REL_TEXT   MSGTXT
------------------------------ --- ---------- ------------------------------------------------------------
PCT                            N
REFRESH_COMPLETE               Y
REFRESH_FAST                   N
REWRITE                        Y
PCT_TABLE                      N   EMP        relation is not a partitioned table
PCT_TABLE                      N   DEPT       relation is not a partitioned table
REFRESH_FAST_AFTER_INSERT      N   AVG_SAL    agg(expr) requires correspondng COUNT(expr) function
REFRESH_FAST_AFTER_ONETAB_DML  N              see the reason why REFRESH_FAST_AFTER_INSERT is disabled
REFRESH_FAST_AFTER_ANY_DML     N              see the reason why REFRESH_FAST_AFTER_ONETAB_DML is disabled
REFRESH_FAST_PCT               N              PCT is not possible on any of the detail tables in the mater
REWRITE_FULL_TEXT_MATCH        Y
REWRITE_PARTIAL_TEXT_MATCH     Y
REWRITE_GENERAL                Y
REWRITE_PCT                    N              general rewrite is not possible or PCT is not possible on an
PCT_TABLE_REWRITE              N   EMP        relation is not a partitioned table
PCT_TABLE_REWRITE              N   DEPT       relation is not a partitioned table

16 rows selected.
</code></pre>

<p>高速リフレッシュが不可で、<code>AVG_SAL</code> 列に関して対応する <code>COUNT(expr)</code> が必要なことを指摘してくれる。</p>

<h2>結合のみを含むマテリアライズド・ビュー</h2>

<p>集計関数は含まずに結合(<code>emp.deptno = dept.deptno</code> など)のみを含むマテリアライズド・ビューを高速リフレッシュ可能にする。</p>

<p>マニュアルから、結合のみを含むマテリアライズド・ビューを高速リフレッシュ可能にするためにはいくつか制限がある。
ざっくり含める必要がある要件をまとめると以下。</p>

<ul>
<li><p>マテリアライズド・ビュー・ログの要件</p>

<ul>
<li><code>ROWID</code> 句を指定</li>
</ul>
</li>
<li><p>マテリアライズド・ビューの SELECT 文に含める要件</p>

<ul>
<li><code>FROM</code> 内の全ての表の ROWID を含める</li>
</ul>
</li>
</ul>


<p>例えば以下の SELECT を含むマテリアライズド・ビューを考える。</p>

<pre><code>SELECT e.ename, d.loc
FROM emp e, dept d
WHERE e.deptno = d.deptno;
</code></pre>

<p>高速リフレッシュ可能なマテリアライズド・ビューを作成する。</p>

<ul>
<li>マテリアライズド・ビュー・ログの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW LOG</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW LOG ON emp
     WITH ROWID;

Materialized view log created.

SQL&gt; CREATE MATERIALIZED VIEW LOG ON dept
     WITH ROWID;

Materialized view log created.
</code></pre>

<ul>
<li>マテリアライズド・ビューの作成</li>
</ul>


<p><code>CREATE MATERIALIZED VIEW</code> 文を実行</p>

<pre><code>SQL&gt; CREATE MATERIALIZED VIEW emp_dept_mv
     BUILD IMMEDIATE
     REFRESH FAST
     ENABLE QUERY REWRITE
     AS SELECT e.ename, d.loc,
               e.rowid e_rowid, d.rowid d_rowid
     FROM emp e, dept d
     WHERE e.deptno = d.deptno;

Materialized view created.
</code></pre>

<ul>
<li>高速リフレッシュ可能か確認</li>
</ul>


<p>先ほど行ったように <code>DBMS_MVIEW.EXPLAIN_MVIEW</code> プロシージャで確認する。</p>

<pre><code>SQL&gt; TRUNCATE TABLE MV_CAPABILITIES_TABLE;

Table truncated.

SQL&gt; EXEC DBMS_MVIEW.EXPLAIN_MVIEW('emp_dept_mv');

PL/SQL procedure successfully completed.

SQL&gt; SELECT capability_name,  possible, SUBSTR(related_text,1,8)
       AS rel_text, SUBSTR(msgtxt,1,60) AS msgtxt
     FROM MV_CAPABILITIES_TABLE
     ORDER BY seq;

CAPABILITY_NAME                POS REL_TEXT   MSGTXT
------------------------------ --- ---------- ------------------------------------------------------------
PCT                            N
REFRESH_COMPLETE               Y
REFRESH_FAST                   Y
REWRITE                        Y
PCT_TABLE                      N   EMP        relation is not a partitioned table
PCT_TABLE                      N   DEPT       relation is not a partitioned table
REFRESH_FAST_AFTER_INSERT      Y
REFRESH_FAST_AFTER_ONETAB_DML  Y
REFRESH_FAST_AFTER_ANY_DML     Y
REFRESH_FAST_PCT               N              PCT is not possible on any of the detail tables in the mater
REWRITE_FULL_TEXT_MATCH        Y
REWRITE_PARTIAL_TEXT_MATCH     Y
REWRITE_GENERAL                Y
REWRITE_PCT                    N              general rewrite is not possible or PCT is not possible on an
PCT_TABLE_REWRITE              N   EMP        relation is not a partitioned table
PCT_TABLE_REWRITE              N   DEPT       relation is not a partitioned table

16 rows selected.
</code></pre>

<p><code>PCT*</code> 以外は <code>possible</code> 列が <code>Y</code> になっているので高速リフレッシュ可能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Oracle] Data Guard ファスト・スタート・フェイルオーバー]]></title>
    <link href="http://th0x4c.github.com/blog/2012/09/11/oracle-data-guard-fast-start-failover/"/>
    <updated>2012-09-11T19:54:00+09:00</updated>
    <id>http://th0x4c.github.com/blog/2012/09/11/oracle-data-guard-fast-start-failover</id>
    <content type="html"><![CDATA[<h2>目的</h2>

<p>Data Guard のファスト・スタート・フェイルオーバーにより、プライマリ DB での障害発生時に自動でフェイルオーバーするようにする。</p>

<h2>環境</h2>

<ul>
<li>OS: Oracle Enterprise Linux 5.8</li>
<li>DB: Oracle Database 11g Release 2 (11.2.0.3)</li>
<li>EM: Oracle Enterprise Manager Grid Control 11g (11.1)</li>
</ul>


<h2>ファスト・スタート・フェイルオーバーの構成</h2>

<p>Data Guard のファスト・スタート・フェイルオーバーにより、プライマリ DB での障害発生時に自動でフェイルオーバーするようにできる。
ファスト・スタート・フェイルオーバーには、プライマリ DB、スタンバイ DB を監視する"オブザーバ"が必要。オブザーバはプライマリ DB、スタンバイ DB とは別のサーバに配置することが望ましいが、今回はスタンバイ DB と同じサーバに構成する。</p>

<p>EM Grid Control を使用してファスト・スタート・フェイルオーバーを有効にする。</p>

<ul>
<li>プライマリ DB インスタンスの "可用性" タブ内の Data Guard の項目から "設定および管理" をクリックして、Data Guard のページを開く</li>
</ul>


<p><img src="/images/2012-09-09-oracle-creating-a-physical-standby-database/dg-14.png" width="720" height="450"></p>

<ul>
<li>"ファスト・スタート・フェイルオーバー" の "無効" をクリック</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-1.png" width="720" height="450"></p>

<ul>
<li>"オブザーバの構成" をクリック</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-2.png" width="720" height="450"></p>

<ul>
<li>オブザーバの場所として今回はスタンバイ DB と同じサーバを指定。ORACLE_HOME の位置も入力する。</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-3.png" width="720" height="450"></p>

<ul>
<li>"続行"</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-4.png" width="720" height="450"></p>

<ul>
<li>オブザーバを起動する OS ユーザを入力</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-5.png" width="720" height="450"></p>

<ul>
<li>"続行"</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-6.png" width="720" height="450"></p>

<ul>
<li>"はい"</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-7.png" width="720" height="450"></p>

<ul>
<li>処理中 -> 完了</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-8.png" width="720" height="450"></p>

<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-9.png" width="720" height="450"></p>

<p>なぜか上記画面のまま "概要" のページに戻らない。alert.log を確認して処理が終わっていそうだったら、EM の画面を切り替えてしまってよい。</p>

<ul>
<li>Data Guard の構成画面に戻ると "ファスト・スタート・フェイルオーバー" が "stdby1.localに対して有効" になり、"オブザーバの場所" が "sv2.local" になっている。(<code>stdby1.local</code> はスタンバイ DB, <code>sv2.local</code> はオブザーバを構成したサーバで今回はスタンバイ DB と同じサーバ)</li>
</ul>


<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-10.png" width="720" height="450"></p>

<h2>ファスト・スタート・フェイルオーバーの検証</h2>

<p>ファスト・スタート・フェイルオーバーが動作するか検証してみる。
<a href="http://docs.oracle.com/cd/E16338_01/server.112/b56304/sofo.htm#BCGHEJFH">マニュアル Data Guard Broker</a> によると次の場合にファスト・スタート・フェイルオーバーが試行される。</p>

<ul>
<li>プライマリ・データベースと、オブザーバおよびターゲット・スタンバイ・データベースの両方との接続が失われた場合</li>
<li>インスタンス障害</li>
<li>強制終了(ABORT オプションでの停止)</li>
</ul>


<p>正常にデータベースを停止した場合(NORMAL, IMMEDIATE, TRANSACTIONAL)では、ファスト・スタート・フェイルオーバーは試行されないので、プライマリ DB を停止するときは通常通り ABORT 以外のオプションで SHUTDOWN すればいい。</p>

<p>ファスト・スタート・フェイルオーバーを検証するためにプライマリ DB を <code>shutdown abort</code> で強制終了する。</p>

<pre><code># プライマリ側で実施
$ export ORACLE_SID=PROD1
$ sqlplus '/as sysdba'
SQL&gt; shutdown abort
ORACLE instance shut down.
</code></pre>

<p>これで、プライマリ DB の異常をオブザーバが検知して、フェイルオーバーが自動で開始される。
オブザーバは Data Guard Broker の dgmgrl コマンドで実行されているので、ログは <code>$ORACLE_HOME/rdbms/log/dgmgrl_XXXX_XXXX.log</code> に出力されている。</p>

<pre><code># オブザーバ配置サーバで実施
$ ps -ef | grep dgmgrl
oracle   12805     1  0 20:27 ?        00:00:01 /u01/app/oracle/product/11.2.0/dbhome_1/bin/dgmgrl -logfile /u01/app/oracle/product/11.2.0/dbhome_1/rdbms/log/dgmgrl_PROD1_12804.log

$ cat $ORACLE_HOME/rdbms/log/dgmgrl_PROD1_12804.log 
Observer started
[W000 09/11 20:27:30.89] Observer started.

21:07:33.37  2012年9月11日 Tuesday
Initiating Fast-Start Failover to database "stdby1"...
Performing failover NOW, please wait...
Failover succeeded, new primary is "stdby1"
21:07:35.66  2012年9月11日 Tuesday
</code></pre>

<p>これで、フェイルオーバーが実施された。EM の元スタンバイ DB 側を確認すると以下のようになっている。</p>

<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-11.png" width="720" height="450"></p>

<p>この後、元プライマリ DB を起動すると、自動でスタンバイ DB として構成してくれる。</p>

<pre><code># 元プライマリ側で実施
$ export ORACLE_SID=PROD1
$ sqlplus '/as sysdba'
SQL&gt; shutdown abort
ORACLE instance shut down.
SQL&gt; startup
ORACLE instance started.

Total System Global Area  835104768 bytes
Fixed Size                  2232960 bytes
Variable Size             511708544 bytes
Database Buffers          314572800 bytes
Redo Buffers                6590464 bytes
Database mounted.
ORA-16649: possible failover to another database prevents this database from
being opened
</code></pre>

<p>オブザーバのログを確認すると、元プライマリ DB が新たにスタンバイ DB としてマウントされたログ出力がある。</p>

<pre><code># オブザーバ配置サーバで実施
$ cat $ORACLE_HOME/rdbms/log/dgmgrl_PROD1_12804.log 
21:18:47.02  2012年9月11日 Tuesday
Initiating reinstatement for database "PROD1"...
Reinstating database "PROD1", please wait...
Operation requires shutdown of instance "PROD1" on database "PROD1"
Shutting down instance "PROD1"...
ORA-01109: database not open

Database dismounted.
ORACLE instance shut down.
Operation requires startup of instance "PROD1" on database "PROD1"
Starting instance "PROD1"...
ORACLE instance started.
Database mounted.
Continuing to reinstate database "PROD1" ...
Reinstatement of database "PROD1" succeeded
21:19:33.19  2012年9月11日 Tuesday
</code></pre>

<p>EM の元スタンバイ DB 側を確認すると以下のように元プライマリ DB が新たにスタンバイ DB として構成されていることが分かる。</p>

<p><img src="/images/2012-09-11-oracle-data-guard-fast-start-failover/dgfsf-12.png" width="720" height="450"></p>

<p>この後、スイッチオーバすれば、元の構成に戻る。</p>
]]></content>
  </entry>
  
</feed>
